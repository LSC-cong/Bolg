[TOC]

# 一、标识符与关键字

## （一）标识符

### 1. 标识符构成规则

- 标识符由数字（0~9）和字母（A~Z 和 a~z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。
- 标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线。
- 注意：Java是大小写敏感的语言；标识符不可以以数字开头；不能使用关键字作为标识符。

## （二）关键字

### 1.定义

**关键字**是对编译器有特殊意义的固定单词，不能在程序中做其他目的使用。

### 2.种类（共 51个）

（1）数据类型：boolean、int、long、short、byte、float、double、char、class、interface。

（2）流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。

（3）修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。

（4）动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。

（5）保留字：true、false、null、goto、const。



# 二、常量与变量

## （一）常量

### 1.定义

```java
final dataType variableName = value
// 静态常量
public static final double PI = 3.14;
// 声明成员常量
final int y = 10;
```

### 2.特点

- **声明常量的同时要赋予一个初始值。常量一旦初始化就不可以被修改。**
- final 关键字不仅可以用来**修饰基本数据类型**的常量，还可以用来**修饰对象的引用**或者**方法**。
- 为了与变量区别，常量取名一般都用大写字符。

## （二）变量

### 1.定义

```java
//方式一
String username;    // 先声明
username = "琪琪";    // 后赋值
//方式二
String username = "琪琪"; // 声明并赋值
```

### 2.特点

- 变量是**类**或者**结构中**的字段，如果没有显式地初始化，默认状态下创建变量并默认初始值为 0。
- **方法中的变量**必须显式地初始化，否则在使用该变量时就会出错。

### 3.变量的作用域

#### （1）成员变量

成员变量有两种：全局变量和静态变量，定义在方法体和代码块之外，**作用域是整个类。**

| 名称                 | 修饰           | 访问                       | 生命周期                                                     |
| -------------------- | -------------- | -------------------------- | ------------------------------------------------------------ |
| 全局变量（实例变量） | 无 static 修饰 | 对象名.变量名              | 只要对象被当作引用，实例变量就将存在                         |
| 静态变量（类变量）   | 用 static 修饰 | 类名.变量名或对象名.变量名 | 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 |

#### （2）局部变量

局部变量：指的是在方法体或代码块中定义的变量，**作用域是方法体或者代码块。**

| 名称           | 生命周期                       | 使用场景                             |
| -------------- | ------------------------------ | ------------------------------------ |
| 方法参数变量   | 即方法的形参，作用域是整个方法 | 方法的形参                           |
| 方法局部变量   | 从定义这个变量开始到方法结束   | 方法中定义的局部变量                 |
| 代码块局部变量 | 从定义这个变量开始到代码块结束 | { }内部的部分，例如try catch代码块中 |

## （三）枚举

### 1.定义

```java
enum Color{
    RED,GREEN,BLUE;
}
```

### 2.特点

枚举类是一种特殊的类，一般表示一组常量。使用`enum`关键字来定义，各常量之间用`，`分隔。

# 三、数据类型



![](https://raw.githubusercontent.com/LSC-cong/Bolg/main/cloudimages/202111180952382.jpeg)

## （一）基本数据类型（8种）

|     **基本类型**     | **位数/bit** | 字节/byte | **包装类** |                     **默认值**                     |   **取值范围**   |
| :------------------: | :----------: | :-------: | :--------: | :------------------------------------------------: | :--------------: |
|      byte(字节)      |      8       |     1     |    Byte    |                         0                          |  -2^7-1 ~ 2^7-1  |
|    short(短整型)     |      16      |     2     |   Short    |                         0                          | -2^15-1 ~ 2^15-1 |
|      int(整型)       |      32      |     4     |  Integer   |                         0                          | -2^31-1 ~ 2^31-1 |
|     long(长整型)     |      64      |     8     |    Long    |                       0 l/L                        | -2^63-1 ~ 2^63-1 |
| float(单精度浮点型)  |      32      |     4     |   Float    |                      0.0 f/F                       | -2^31-1 ~ 2^31-1 |
| double(双精度浮点型) |      64      |     8     |   Double   |                      0.0 (d)                       | -2^63-1 ~ 2^63-1 |
|     char(字符型)     |      16      |     2     | Character  | '\u0000'（对应数字0，输出为空。存储的是Unicode码） |    0 ~ 2^16-1    |
|   boolean(布尔型)    |      8       |     1     |  Boolean   |                       false                        |   true、false    |

==注意：==字符型通常使用16进制表示，范围是“\u0000~\uffff”。\uxxxx后面跟着的xxxx是：Unicode码。**Unicode码一般使用2个字节，16位二进制表示，总共可以表示2^16^个字符**

### 1.自动类型转换

byte, short, char —> int —> long —> float —> double

- **不同的数据类型进行混合运算**时，运算中不同类型的数据先转换为同一类型，再进行运算。（boolean类型不可以参与混合运算）

- 自动类型转换必须要求：转换前的数据类型位数要**低于**转换后的数据类型位数

```JAVA
char c='a';//定义一个char类型
int i = c;//char自动类型转换为int
System.out.println("char自动类型转换为int后的值等于"+i);
//结果：char自动类型转换为int后的值等于97
```

### 2.强制类型转换

- 当高位数的数据类型转为低位数的数据类型时，需要进行强制类型转换。会有一定的精度损失。

```java
float i = 129.1f;
int j = (int) i;//float强制类型转换为int
System.out.println("float强制类型转换为int后的值等于"+j);
//结果：float强制类型转换为int后的值等于129
```



## （二）引用数据类型（3种）

### 1. 类

### 2. 接口

### 3. 数组



## （三）转义字符类型

|  符号  | 字符含义                 |
| :----: | :----------------------- |
|   \n   | 换行 (0x0a)              |
|   \r   | 回车 (0x0d)              |
|   \f   | 换页符(0x0c)             |
|   \b   | 退格 (0x08)              |
|   \0   | 空字符 (0x0)             |
|   \s   | 空格 (0x20)              |
|   \t   | 制表符                   |
|  \\"   | 双引号                   |
|  \\'   | 单引号                   |
|  \\\   | 反斜杠                   |
|  \ddd  | 八进制字符 (ddd)         |
| \uxxxx | 16进制Unicode字符 (xxxx) |

 

# 四、运算符

## （一）算数运算符

| 算数运算符 | 描述       |
| :--------: | :--------- |
|   + - *    | 加 减 乘   |
|     \      | 除（取整） |
|     %      | 取余       |
|   ++ --    | 自增 自减  |

- 注意：
  - 不同位数的数据类型进行混合运算时，会进行自动类型转换，注意精度的变化

## （二）关系运算符

| 关系运算符 | 描述                                                         |
| :--------: | :----------------------------------------------------------- |
|     ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。         |
|     !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。     |
|     >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。   |
|     <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。   |
|     >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 |
|     <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 |

## （三）位运算符

```
假设：
A = 0011 1100
B = 0000 1101
```

| 位运算符 | 描述                                                         |              例子               |
| :------: | :----------------------------------------------------------- | :-----------------------------: |
|    ＆    | 如果相对应位都是1，则结果为1，否则为0                        |  （A＆B），得到12，即0000 1100  |
|    \|    | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011  1101 |
|    ^     | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011  0001  |
|    〜    | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         |   （〜A）得到-61，即1100 0011   |
|    <<    | 按位左移运算符。左操作数按位左移右操作数指定的位数。         |  A  << 2得到240，即 1111 0000   |
|    >>    | 按位右移运算符。左操作数按位右移右操作数指定的位数。         |      A  >> 2得到15即 1111       |
|   >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 |     A>>>2得到15即0000 1111      |

## （四）逻辑运算符

| 逻辑运算符 | 描述                                                         |        例子         |
| :--------: | :----------------------------------------------------------- | :-----------------: |
|     &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。     |  （A && B）为假。   |
|   \| \|    | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \| \| B）为真。 |
|     ！     | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |

## （五）赋值运算符

| 赋值运算符 | 描述                                                         | 例子                                     |
| :--------- | :----------------------------------------------------------- | :--------------------------------------- |
| =          | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |
| + =        | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |
| - =        | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |
| * =        | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |
| / =        | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |
| （％）=    | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |
| << =       | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |
| >> =       | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |
| ＆=        | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |
| ^ =        | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |
| \| =       | 按位或赋值操作符                                             | C \| = 2等价于C = C \| 2                 |

## （六）条件运算符

```java
variable x = (expression) ? value if true : value if false
```

```java
int a , b;
a = 10;
// 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
b = (a == 1) ? 20 : 30;
System.out.println( "Value of b is : " +  b );//30

// 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
b = (a == 10) ? 20 : 30;
System.out.println( "Value of b is : " + b );//20
```

## （七）instanceof运算符

```java
( Object reference variable ) instanceof  (class/interface type)
```

```java
Vehicle a = new Car();
boolean result =  a instanceof Car;
System.out.println(result);//true
```



# 五、修饰符

## （一）访问控制符

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)                                               | 其他包 |
| :---------- | :----- | :------- | :------------- | :----------------------------------------------------------- | :----- |
| `public`    | √      | √        | √              | √                                                            | √      |
| `protected` | √      | √        | √              | √/×（[说明](https://www.runoob.com/java/java-modifier-types.html#protected-desc)） | ×      |
| `default`   | √      | √        | √              | ×                                                            | ×      |
| `private`   | √      | ×        | ×              | ×                                                            | ×      |

## （二）非访问控制符

|     修饰符     | 修饰对象       | 作用                                                         |
| :------------: | :------------- | ------------------------------------------------------------ |
|    `static`    | 方法、变量     | static修饰的方法为静态方法、类为静态类                       |
|    `final `    | 类、方法、变量 | final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 |
|  `abstract `   | 类、方法       | abstract修饰的方法为抽象方法、类为抽象类                     |
| `synchronized` | 方法、代码块   | synchronized修饰的方法或代码块，保证多线程环境下，任意时刻只能有一个线程执行。保证原子性、可见性、有序性 |
|   `volatile`   | 变量           | volatile修饰的变量，保证多线程环境下的可见性和有序性         |
|  `transient`   | 变量           | 类实现了Serilizable接口，那么类的所有属性和方法都可以自动被序列化，transient修饰的变量不会进行序列化 |



# 六、控制流程

## （一）条件语句

### 1. if\......else语句

```java
if(布尔表达式 1){
   //如果布尔表达式 1的值为true执行代码
}else if(布尔表达式 2){
   //如果布尔表达式 2的值为true执行代码
}else if(布尔表达式 3){
   //如果布尔表达式 3的值为true执行代码
}else {
   //如果以上布尔表达式都不为true执行代码
}
```

### 2.switch......case语句

```java
switch(布尔表达式){
    case value1 :
       //语句
       break; //可选
    case value2 :
       //语句
       break; //可选
    //你e可以有任意数量的case语句
    default : //可选
       //语句
}
```



## （二）循环语句

### 1.for语句

```java
//方式一
for(初始化; 布尔表达式; 更新) {
    //循环内容
}
//例子
for(int x = 10; x < 13; ++x) {
    System.out.print("value of x : " + x );
    System.out.print("\n");
}
/*
value of x : 10
value of x : 11
value of x : 12
*/

//方式二————常用于数组
//声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。
//表达式：表达式是要访问的数组名，或者是返回值为数组的方法。
for(声明语句 : 表达式)
{
   //循环内容
}
//例子
String [] names ={"James", "Larry", "Tom", "Lacy"};
for( String name : names ) {
    System.out.print( name + ",");//James,Larry,Tom,Lacy,
}
```

### 2.while语句

```java
while( 布尔表达式 ) {
    //循环内容
}
```

### 3.do......while语句

```java
do {
    //循环内容
}while(布尔表达式);
```

==**注意：**==while语句如果布尔表达式不满足条件，则不会进入循环。do......while与while相似，但是**do......while至少会执行一次**



## （三）关键字

### 1.return

​		**return关键字并不是专门用于结束循环的，return语句用于终止函数的执行或退出类的方法，并把控制权返回给该方法的调用者。**如果这个方法带有返回类型，return语句就必须返回这个类型的值；如果这个方法没有返回值，可以使用没有表达式的 return 语句。

### 2.continue

​		**continue 语句是跳过循环体中剩余的语句而强制执行下一次循环，其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，接着进行下一次是否执行循环的判定。**

### 3.break

​		**break 用于完全结束一个循环，跳出循环体。**不管是哪种循环，一旦在循环体中遇到 break，系统将完全结束该循环，开始执行循环之后的代码。





# 七、数组

## （一）特点

1. 数组是一种**引用数据类型**，也是一种数据结构；
2. 数组可以用于存储多个元素，所有的元素具有相同的数据类型；
3. **可以通过数组元素的索引（整型下标）访问数组元素**；

## （二）定义

### 1. 一维数组

```java
//1.声明数组并直接赋值
int[] arr1 = {1,2,3,4,5};
//2.先声明数组，再开辟空间并直接赋值
int[] arr1;
arr1 = new int[]{1,2,3,4,5};
//3.先声明数组并指定数组空间大小，再赋值
int[] arr1 = new int[5];
for(int i=0; i<arr1.length; i++){
	arr1[i] = i+1;
}
```

### 2. 多维数组

```java
//多维数组
//1.声明数组并直接赋值。多维数组每个子数组的元素个数 不要求 都相同
int[][] arr2 = {{1,2},
                {3,4,5}};
//2.先声明数组并指定数组空间大小，再赋值
int[][] arr2 = new int[2][3];
//或者
int[][] arr2;
arr2 = new int[2][3];

for(int i=0; i<arr2.length; i++){
	for(int j=0; j<arr2[0].length; j++){
		//对arr2[i][j]赋值
	}
}
//3.动态定义多维数组，可以只定义多维数组的第一个维度的长度，后面维度的长度可以之后再定义
int[][] arr3 = new int[2][];
for(int i=0; i<arr3.length; i++){
	//对第二个维度再定义长度
    arr3[0] = new int[2];
	arr3[1] = new int[3];
}
```

### 3. 数组的遍历方法

```java
//使用for循环
//一维数组
int[] arr1 = {1,2,3,4,5};
for(int i=0; i<arr1.length; i++){
    System.out.println(arr[i]);
}
//多维数组
int[][] arr2 = {{1,2},
                {3,4,5}};
for(int i=0; i<arr2.length; i++){
    for(int j=0; j<arr2[i].length; j++){
        System.out.println(arr2[i][j]);
    }
}

//使用for each遍历
//一维数组
int[] arr1 = {1,2,3,4,5};
for(int i : arr1){
    System.out.println(i);
}
//多维数组
int[][] arr2 = {{1,2},
              {3,4,5}};
for(int[] i : arr2){
    for(int j : i){
        System.out.println(j);
    }
}
```



# 八、字符串

## （一）String

### 1. 定义

（1）直接定义

直接定义的字符串是Java中唯一不需要new就可以产生对象的途径,称之为**直接量**。

```java
String str = "Hello";
//或者
String str;
str = "Hello";
```

（2）直接定义

```java
//方式二 类定义
//String(String original)
String str1 = new String("Hello");
String str2 = new String(str1);//str1和str2的equals相等，但是==不等
//或者
//String(char[ ]value)
char arr[] = {'H','e','l','l','0'};
String str = new String(arr);//字符数组的内容已被复制为一个新的字符串,后续对字符数组的修改不会影响新创建的字符串
//或者
//String(char[] value,int offset,int count),offset 参数是子数组第一个字符的索引，count 参数指定子数组的长度。
char a[]={'H','e','l','l','o'};
String sChar=new String(a,1,4);

```

### 2. 对字符串的操作

#### (1)String和int的转换

##### 1)String转int

```java
String str = "123";
int i = Integer.parseInt(str);
int i = Integer.valueOf(str).intValue();
```

##### 2)int转String

```java
int i = 123;
String s = String.valueOf(i);
String s = Integer.toString(i);
String s = "" + i;
```



#### (2)String的三个方法

##### 1)valueOf()

##### 2)parseXxx()

##### 3)toString()



#### (3)String拼接

##### 1)使用连接运算符"+"

​	字符串与字符串相连得到的结果是字符串;但是若字符串与其他数据类型相连,编译器会将其他数据类型转换成字符串形式

##### 2)使用concat()方法

concat()方法用于连接两个字符串

```java
String info = "三国演义和";
info = info.concat("西游记");
```



#### (4)String的重要方法

##### 1)获取字符串长度

```java
//获取字符串长度
String str = "abcd";
int len = str.length();
//获取数组长度
int[] arr = {1,2,3};
int len = arr.length;
//获取集合长度
ArrayList<Integer> arrlist = new ArrayList<>();
int len = arrlist.size();
```

##### 2)大小写转换

```java
String str="abcdef 我 ghijklmn";
System.out.println(str.toLowerCase());    // abcdef 我 ghijklmn
System.out.println(str.toUpperCase());    // ABCDEF 我 GHIJKLMN
```

##### 3)去除字符串中的空格

```java
String str = "你 hello 啊";
System.out.println(str.trim());//你hello啊
```

##### 4)提取子字符串

```java
//1. substring(int beginIndex) 形式,提取从索引位置开始至结尾处的字符串部分
String str = "我爱Java编程";
String result = str.substring(2);
System.out.println(result);    // Java编程

//2. substring(int beginIndex，int endIndex) 形式,提取位置 beginIndex 和位置 endIndex 位置之间的字符串部分.左闭右开
String str = "我爱Java编程";
String result = str.substring(2,6);
System.out.println(result);    // Java

```

##### 5)字符串分割

- "."和"|"都是转义字符,必须加"\\\\"
- 如果需要使用多个分隔符,可以用"|"作为连字符

```java
//1.str.split(String sign)
String Colors = "Red,Black,White,Yellow,Blue";
String[] arr1 = Colors.split(","); // 不限制元素个数
//输出为:
//Red
//Black
//White
//Yellow
//Blue

//2.str.split(String sign,int limit)
String[] arr2 = Colors.split(",", 3); // 限制元素个数为3,即分割后的结果只有三个元素
//输出为:
//Red
//Black
//White,Yellow,Blue
```

##### 6)字符串替换

```Java
//直接替换字符串中的所有字符--字符串.replace(String oldChar, String newChar)
String words = "hello java,hello php";
System.out.println(words.replace("hello","你好"));//你好 java,你好 php

//第一个参数是正则表达式
//将目标字符串中匹配某正则表达式的第一个子字符串替换成新的字符串,字符串.replaceFirst(String regex,String newChar)
//将目标字符串中匹配某正则表达式的所有子字符串替换成新的字符串,字符串.replaceAll(String regex,String newChar) 
String intro = "今天时星其天，外面时下雨天。妈米去买菜了，漏网在家写作业。语文作业时”其”写 5 行，数学使第 10 页。";
// 将文本中的所有"时"和"使"都替换为"是"
String newStrFirst = intro.replaceAll("[时使]", "是");
// 将文本中的所有"妈米"改为"妈妈"
String newStrSecond = newStrFirst.replaceAll("妈米", "妈妈");
// 将文本中的所有"漏网"改为"留我"
String newStrThird = newStrSecond.replaceAll("漏网", "留我");
// 将文本中第一次出现的"其"改为"期"
String newStrFourth = newStrThird.replaceFirst("[其]", "期");

//输出结果:今天是星期天，外面是下雨天。妈妈去买菜了，留我在家写作业。语文作业是”其”写 5 行，数学是第 10 页。

```

##### 7)字符串比较

- equals()方法----比较字符串的字面量是否相等
- equalsIgnoreCase()方法----忽视大小写判断两个字符串字面量是否相等
- compraeTo()方法----按字典顺序比较两个字符串的大小,基于各个字符的Unicode码来比较

```java
String str = "A";
String str1 = "a";
System.out.println("str.compareTo(str1)的结果是：" + str.compareTo(str1));
System.out.println("str1.compareTo(str)的结果是：" + str1.compareTo(str));
System.out.println("str1.compareTo('a')的结果是：" + str1.compareTo("a"));
/*str.compareTo(str1)的结果是：-32
  str1.compareTo(str)的结果是：32
  str1.compareTo('a')的结果是：0
 */
```

##### 8)字符串查找

- indexOf()方法----返回字符（串）在指定字符串中首次出现的索引位置，如果能找到，则返回索引值，否则返回 -1

```java
//str 表示指定字符串；value 表示待查找的字符（串）；fromIndex 表示查找时的起始索引
//str.indexOf(value)
//str.indexOf(value,int fromIndex)
String s = "Hello Java";
int size = s.indexOf('v');    // size的结果为8
```

- lastlndexOf() 方法----返回字符（串）在指定字符串中最后一次出现的索引位置，如果能找到则返回索引值，否则返回 -1

> **indexOf()和lastIndexOf()方法功能相似,前者从左往右,查找第一个出现的字符,后者从右往左,查找第一个出现的字符**

- charAt()方法----在字符串内,根据指定的索引查找字符

```java
String words = "today,monday,sunday";
System.out.println(words.charAt(0));    // 结果：t
System.out.println(words.charAt(1));    // 结果：o
System.out.println(words.charAt(8));    // 结果：n
```



## （二）StringBuffer和StringBulilder

### 1.StringBuffer类

#### (1)构造方法

- StringBuffer() 构造一个空的字符串缓冲区，并且初始化为 16 个字符的容量。
- StringBuffer(int length) 创建一个空的字符串缓冲区，并且初始化为指定长度 length 的容量。
- StringBuffer(String str) 创建一个字符串缓冲区，并将其内容初始化为指定的字符串内容 str，字符串缓冲区的初始容量为 16 加上字符串 str 的长度。

#### (2)追加字符串

```java
StringBuffer buffer = new StringBuffer("hello,");    // 创建一个 StringBuffer 对象
String str = "World!";
buffer.append(str);    // 向 StringBuffer 对象追加 str 字符串
System.out.println(buffer);    //hello,world!
```

#### (3)替换字符

```java
StringBuffer sb = new StringBuffer("hello");
sb.setCharAt(1,'E');
System.out.println(sb);    // 输出：hEllo
```

#### (4)反转字符串

```java
StringBuffer sb = new StringBuffer("1234");
sb.reverse();
System.out.println(sb);    // 输出：4321
```

#### (5)删除字符

##### 1)deleteCharAt(int Index)方法----用于移除指定位置的字符

```java
StringBuffer sb = new StringBuffer("abcde");
sb.deleteCharAt(2);
System.out.println(sb);    // 输出：abde
```

##### 2)delete(int start, int end)方法----用于移除序列中子字符串的字符

```java
StringBuffer sb = new StringBuffer("hello jack");
sb.delete(2,5);			   //左闭右开
System.out.println(sb);    // 输出：he jack
```

### 2.StringBuilder类

> 与StringBuffer类功能基本相似,方法也基本差不多

### 3.String、StringBuffer、StringBuilder对比

(1)String类是不可以变的类,即一旦一个String对象被创建后,包含在在这个对象中的字符序列是不可变的,直到这个对象被销毁

(2)StringBuffer和StringBuilder相似,但是**StringBuffer是线程安全的**,**StringBuilder不是线程安全的,所以性能略高**

(3)CharSequence 是一个定义字符串操作的接口，它只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个 API。

![image-20211123220056827](https://raw.githubusercontent.com/LSC-cong/Bolg/main/cloudimages/202111232201950.png)

(4)总结

- **操作少量的数据使用 String。**
- **单线程操作大量数据使用 StringBuilder。**
- **多线程操作大量数据使用 StringBuffer。**

# 九、数字和日期

## (一)Math类的常用方法

### 1. 静态常量

```java
System.out.println("E 常量的值：" + Math.E);
System.out.println("PI 常量的值：" + Math.PI);
//E 常量的值：2.718281828459045
//PI 常量的值：3.141592653589793
```

### 2. 静态方法

#### (1)最大最小和绝对值

```java
System.out.println("10 和 20 的较大值：" + Math.max(10, 20));
System.out.println("15.6 和 15 的较小值：" + Math.min(15.6, 15));
System.out.println("-12 的绝对值：" + Math.abs(-12));
//10和20的较大值：20
//15.6和15的较小值：15.0
//-12的绝对值：12
```

#### (2)求整运算

```java
```





# 十、内置包装类



