[TOC]

# 一、标识符与关键字

## （一）标识符

### 1. 标识符构成规则

- 标识符由数字（0~9）和字母（A~Z 和 a~z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。
- 标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线。
- 注意：Java是大小写敏感的语言；标识符不可以以数字开头；不能使用关键字作为标识符。

## （二）关键字

### 1.定义

**关键字**是对编译器有特殊意义的固定单词，不能在程序中做其他目的使用。

### 2.种类（共 51个）

（1）数据类型：boolean、int、long、short、byte、float、double、char、class、interface。

（2）流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。

（3）修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。

（4）动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。

（5）保留字：true、false、null、goto、const。



# 二、常量与变量

## （一）常量

### 1.定义

```java
final dataType variableName = value
// 静态常量
public static final double PI = 3.14;
// 声明成员常量
final int y = 10;
```

### 2.特点

- **声明常量的同时要赋予一个初始值。常量一旦初始化就不可以被修改。**
- final 关键字不仅可以用来**修饰基本数据类型**的常量，还可以用来**修饰对象的引用**或者**方法**。
- 为了与变量区别，常量取名一般都用大写字符。

## （二）变量

### 1.定义

```java
//方式一
String username;    // 先声明
username = "琪琪";    // 后赋值
//方式二
String username = "琪琪"; // 声明并赋值
```

### 2.特点

- 变量是**类**或者**结构中**的字段，如果没有显式地初始化，默认状态下创建变量并默认初始值为 0。
- **方法中的变量**必须显式地初始化，否则在使用该变量时就会出错。

### 3.变量的作用域

#### （1）成员变量

成员变量有两种：全局变量和静态变量，定义在方法体和代码块之外，**作用域是整个类。**

| 名称                 | 修饰           | 访问                       | 生命周期                                                     |
| -------------------- | -------------- | -------------------------- | ------------------------------------------------------------ |
| 全局变量（实例变量） | 无 static 修饰 | 对象名.变量名              | 只要对象被当作引用，实例变量就将存在                         |
| 静态变量（类变量）   | 用 static 修饰 | 类名.变量名或对象名.变量名 | 其生命周期取决于类的生命周期。类被垃圾回收机制彻底回收时才会被销毁 |

#### （2）局部变量

局部变量：指的是在方法体或代码块中定义的变量，**作用域是方法体或者代码块。**

| 名称           | 生命周期                       | 使用场景                             |
| -------------- | ------------------------------ | ------------------------------------ |
| 方法参数变量   | 即方法的形参，作用域是整个方法 | 方法的形参                           |
| 方法局部变量   | 从定义这个变量开始到方法结束   | 方法中定义的局部变量                 |
| 代码块局部变量 | 从定义这个变量开始到代码块结束 | { }内部的部分，例如try catch代码块中 |

## （三）枚举

### 1.定义

```java
enum Color{
    RED,GREEN,BLUE;
}
```

### 2.特点

枚举类是一种特殊的类，一般表示一组常量。使用`enum`关键字来定义，各常量之间用`，`分隔。

# 三、数据类型



![](https://raw.githubusercontent.com/LSC-cong/Bolg/main/cloudimages/202111180952382.jpeg)

## （一）基本数据类型（8种）

|     **基本类型**     | **位数/bit** | 字节/byte | **包装类** |                     **默认值**                     |   **取值范围**   |
| :------------------: | :----------: | :-------: | :--------: | :------------------------------------------------: | :--------------: |
|      byte(字节)      |      8       |     1     |    Byte    |                         0                          |  -2^7-1 ~ 2^7-1  |
|    short(短整型)     |      16      |     2     |   Short    |                         0                          | -2^15-1 ~ 2^15-1 |
|      int(整型)       |      32      |     4     |  Integer   |                         0                          | -2^31-1 ~ 2^31-1 |
|     long(长整型)     |      64      |     8     |    Long    |                       0 l/L                        | -2^63-1 ~ 2^63-1 |
| float(单精度浮点型)  |      32      |     4     |   Float    |                      0.0 f/F                       | -2^31-1 ~ 2^31-1 |
| double(双精度浮点型) |      64      |     8     |   Double   |                      0.0 (d)                       | -2^63-1 ~ 2^63-1 |
|     char(字符型)     |      16      |     2     | Character  | '\u0000'（对应数字0，输出为空。存储的是Unicode码） |    0 ~ 2^16-1    |
|   boolean(布尔型)    |      8       |     1     |  Boolean   |                       false                        |   true、false    |

==注意：==字符型通常使用16进制表示，范围是“\u0000~\uffff”。\uxxxx后面跟着的xxxx是：Unicode码。**Unicode码一般使用2个字节，16位二进制表示，总共可以表示2^16^个字符**

### 1.自动类型转换

byte, short, char —> int —> long —> float —> double

- **不同的数据类型进行混合运算**时，运算中不同类型的数据先转换为同一类型，再进行运算。（boolean类型不可以参与混合运算）

- 自动类型转换必须要求：转换前的数据类型位数要**低于**转换后的数据类型位数

```JAVA
char c='a';//定义一个char类型
int i = c;//char自动类型转换为int
System.out.println("char自动类型转换为int后的值等于"+i);
//结果：char自动类型转换为int后的值等于97
```

### 2.强制类型转换

- 当高位数的数据类型转为低位数的数据类型时，需要进行强制类型转换。会有一定的精度损失。

```java
float i = 129.1f;
int j = (int) i;//float强制类型转换为int
System.out.println("float强制类型转换为int后的值等于"+j);
//结果：float强制类型转换为int后的值等于129
```



## （二）引用数据类型（3种）

### 1. 类

### 2. 接口

### 3. 数组



## （三）转义字符类型

|  符号  | 字符含义                 |
| :----: | :----------------------- |
|   \n   | 换行 (0x0a)              |
|   \r   | 回车 (0x0d)              |
|   \f   | 换页符(0x0c)             |
|   \b   | 退格 (0x08)              |
|   \0   | 空字符 (0x0)             |
|   \s   | 空格 (0x20)              |
|   \t   | 制表符                   |
|  \\"   | 双引号                   |
|  \\'   | 单引号                   |
|  \\\   | 反斜杠                   |
|  \ddd  | 八进制字符 (ddd)         |
| \uxxxx | 16进制Unicode字符 (xxxx) |

 

# 四、运算符

## （一）算数运算符

| 算数运算符 | 描述       |
| :--------: | :--------- |
|   + - *    | 加 减 乘   |
|     \      | 除（取整） |
|     %      | 取余       |
|   ++ --    | 自增 自减  |

- 注意：
  - 不同位数的数据类型进行混合运算时，会进行自动类型转换，注意精度的变化

## （二）关系运算符

| 关系运算符 | 描述                                                         |
| :--------: | :----------------------------------------------------------- |
|     ==     | 检查如果两个操作数的值是否相等，如果相等则条件为真。         |
|     !=     | 检查如果两个操作数的值是否相等，如果值不相等则条件为真。     |
|     >      | 检查左操作数的值是否大于右操作数的值，如果是那么条件为真。   |
|     <      | 检查左操作数的值是否小于右操作数的值，如果是那么条件为真。   |
|     >=     | 检查左操作数的值是否大于或等于右操作数的值，如果是那么条件为真。 |
|     <=     | 检查左操作数的值是否小于或等于右操作数的值，如果是那么条件为真。 |

## （三）位运算符

```
假设：
A = 0011 1100
B = 0000 1101
```

| 位运算符 | 描述                                                         |              例子               |
| :------: | :----------------------------------------------------------- | :-----------------------------: |
|    ＆    | 如果相对应位都是1，则结果为1，否则为0                        |  （A＆B），得到12，即0000 1100  |
|    \|    | 如果相对应位都是 0，则结果为 0，否则为 1                     | （A \| B）得到61，即 0011  1101 |
|    ^     | 如果相对应位值相同，则结果为0，否则为1                       | （A ^ B）得到49，即 0011  0001  |
|    〜    | 按位取反运算符翻转操作数的每一位，即0变成1，1变成0。         |   （〜A）得到-61，即1100 0011   |
|    <<    | 按位左移运算符。左操作数按位左移右操作数指定的位数。         |  A  << 2得到240，即 1111 0000   |
|    >>    | 按位右移运算符。左操作数按位右移右操作数指定的位数。         |      A  >> 2得到15即 1111       |
|   >>>    | 按位右移补零操作符。左操作数的值按右操作数指定的位数右移，移动得到的空位以零填充。 |     A>>>2得到15即0000 1111      |

## （四）逻辑运算符

| 逻辑运算符 | 描述                                                         |        例子         |
| :--------: | :----------------------------------------------------------- | :-----------------: |
|     &&     | 称为逻辑与运算符。当且仅当两个操作数都为真，条件才为真。     |  （A && B）为假。   |
|   \| \|    | 称为逻辑或操作符。如果任何两个操作数任何一个为真，条件为真。 | （A \| \| B）为真。 |
|     ！     | 称为逻辑非运算符。用来反转操作数的逻辑状态。如果条件为true，则逻辑非运算符将得到false。 | ！（A && B）为真。  |

## （五）赋值运算符

| 赋值运算符 | 描述                                                         | 例子                                     |
| :--------- | :----------------------------------------------------------- | :--------------------------------------- |
| =          | 简单的赋值运算符，将右操作数的值赋给左侧操作数               | C = A + B将把A + B得到的值赋给C          |
| + =        | 加和赋值操作符，它把左操作数和右操作数相加赋值给左操作数     | C + = A等价于C = C + A                   |
| - =        | 减和赋值操作符，它把左操作数和右操作数相减赋值给左操作数     | C - = A等价于C = C - A                   |
| * =        | 乘和赋值操作符，它把左操作数和右操作数相乘赋值给左操作数     | C * = A等价于C = C * A                   |
| / =        | 除和赋值操作符，它把左操作数和右操作数相除赋值给左操作数     | C / = A，C 与 A 同类型时等价于 C = C / A |
| （％）=    | 取模和赋值操作符，它把左操作数和右操作数取模后赋值给左操作数 | C％= A等价于C = C％A                     |
| << =       | 左移位赋值运算符                                             | C << = 2等价于C = C << 2                 |
| >> =       | 右移位赋值运算符                                             | C >> = 2等价于C = C >> 2                 |
| ＆=        | 按位与赋值运算符                                             | C＆= 2等价于C = C＆2                     |
| ^ =        | 按位异或赋值操作符                                           | C ^ = 2等价于C = C ^ 2                   |
| \| =       | 按位或赋值操作符                                             | C \| = 2等价于C = C \| 2                 |

## （六）条件运算符

```java
variable x = (expression) ? value if true : value if false
```

```java
int a , b;
a = 10;
// 如果 a 等于 1 成立，则设置 b 为 20，否则为 30
b = (a == 1) ? 20 : 30;
System.out.println( "Value of b is : " +  b );//30

// 如果 a 等于 10 成立，则设置 b 为 20，否则为 30
b = (a == 10) ? 20 : 30;
System.out.println( "Value of b is : " + b );//20
```

## （七）instanceof运算符

```java
( Object reference variable ) instanceof  (class/interface type)
```

```java
Vehicle a = new Car();
boolean result =  a instanceof Car;
System.out.println(result);//true
```



# 五、修饰符

## （一）访问控制符

| 修饰符      | 当前类 | 同一包内 | 子孙类(同一包) | 子孙类(不同包)                                               | 其他包 |
| :---------- | :----- | :------- | :------------- | :----------------------------------------------------------- | :----- |
| `public`    | √      | √        | √              | √                                                            | √      |
| `protected` | √      | √        | √              | √/×（[说明](https://www.runoob.com/java/java-modifier-types.html#protected-desc)） | ×      |
| `default`   | √      | √        | √              | ×                                                            | ×      |
| `private`   | √      | ×        | ×              | ×                                                            | ×      |

## （二）非访问控制符

|     修饰符     | 修饰对象       | 作用                                                         |
| :------------: | :------------- | ------------------------------------------------------------ |
|    `static`    | 方法、变量     | static修饰的方法为静态方法、类为静态类                       |
|    `final `    | 类、方法、变量 | final 修饰的类不能够被继承，修饰的方法不能被继承类重新定义，修饰的变量为常量，是不可修改的。 |
|  `abstract `   | 类、方法       | abstract修饰的方法为抽象方法、类为抽象类                     |
| `synchronized` | 方法、代码块   | synchronized修饰的方法或代码块，保证多线程环境下，任意时刻只能有一个线程执行。保证原子性、可见性、有序性 |
|   `volatile`   | 变量           | volatile修饰的变量，保证多线程环境下的可见性和有序性         |
|  `transient`   | 变量           | 类实现了Serilizable接口，那么类的所有属性和方法都可以自动被序列化，transient修饰的变量不会进行序列化 |



# 六、控制流程

## （一）条件语句

### 1. if\......else语句

```java
if(布尔表达式 1){
   //如果布尔表达式 1的值为true执行代码
}else if(布尔表达式 2){
   //如果布尔表达式 2的值为true执行代码
}else if(布尔表达式 3){
   //如果布尔表达式 3的值为true执行代码
}else {
   //如果以上布尔表达式都不为true执行代码
}
```

### 2.switch......case语句

```java
switch(布尔表达式){
    case value1 :
       //语句
       break; //可选
    case value2 :
       //语句
       break; //可选
    //你e可以有任意数量的case语句
    default : //可选
       //语句
}
```



## （二）循环语句

### 1.for语句

```java
//方式一
for(初始化; 布尔表达式; 更新) {
    //循环内容
}
//例子
for(int x = 10; x < 13; ++x) {
    System.out.print("value of x : " + x );
    System.out.print("\n");
}
/*
value of x : 10
value of x : 11
value of x : 12
*/

//方式二————常用于数组
//声明语句：声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。
//表达式：表达式是要访问的数组名，或者是返回值为数组的方法。
for(声明语句 : 表达式)
{
   //循环内容
}
//例子
String [] names ={"James", "Larry", "Tom", "Lacy"};
for( String name : names ) {
    System.out.print( name + ",");//James,Larry,Tom,Lacy,
}
```

### 2.while语句

```java
while( 布尔表达式 ) {
    //循环内容
}
```

### 3.do......while语句

```java
do {
    //循环内容
}while(布尔表达式);
```

==**注意：**==while语句如果布尔表达式不满足条件，则不会进入循环。do......while与while相似，但是**do......while至少会执行一次**



## （三）关键字

### 1.return

​		**return关键字并不是专门用于结束循环的，return语句用于终止函数的执行或退出类的方法，并把控制权返回给该方法的调用者。**如果这个方法带有返回类型，return语句就必须返回这个类型的值；如果这个方法没有返回值，可以使用没有表达式的 return 语句。

### 2.continue

​		**continue 语句是跳过循环体中剩余的语句而强制执行下一次循环，其作用为结束本次循环，即跳过循环体中下面尚未执行的语句，接着进行下一次是否执行循环的判定。**

### 3.break

​		**break 用于完全结束一个循环，跳出循环体。**不管是哪种循环，一旦在循环体中遇到 break，系统将完全结束该循环，开始执行循环之后的代码。





# 七、数组

## （一）特点

1. 数组是一种**引用数据类型**，所以也是一种数据结构。例如int是一个基本类型，但是int[]是一种引用类型
2. 数组可以用于存储多个元素，**所有的元素具有相同的数据类型**；
3. **可以通过数组元素的索引（整型下标）访问数组元素**；

## （二）一维数组

### 1. 声明数组并直接赋值

```java
int[] arr1 = {1,2,3,4,5};
```

### 2. 先声明数组，再开辟空间并直接赋值

```java
int[] arr1;//声明数组
arr1 = new int[]{1,2,3,4,5};
```

### 3. 先声明数组并指定数组空间大小，再赋值

```java
int[] arr1 = new int[5];//声明数组并分配空间
for(int i=0; i<arr1.length; i++){
	arr1[i] = i+1;
}
```

> 如果程序员只指定了数组的长度，那么系统将负责为这些数组元素分配初始值：
>
> - 数组元素的类型是基本类型中的整数类型（byte、short、int 和 long），则数组元素的值是 0。
> - 数组元素的类型是基本类型中的浮点类型（float、double），则数组元素的值是 0.0。
> - 数组元素的类型是基本类型中的字符类型（char），则数组元素的值是‘\u0000’。
> - 数组元素的类型是基本类型中的布尔类型（boolean），则数组元素的值是 false。
> - 数组元素的类型是引用类型（类、接口和数组），则数组元素的值是 null。



## （二）多维数组

### 1. 声明数组并直接赋值

```java
//多维数组每个子数组的元素个数 不要求 都相同
int[][] arr2 = {{1,2},
                {3,4,5}};
```

### 2. 先声明数组并指定数组空间大小，再赋值

```java
int[][] arr2 = new int[2][3];
//或者
int[][] arr2;
arr2 = new int[2][3];

//二维数组赋值
for(int i=0; i<arr2.length; i++){
	for(int j=0; j<arr2[0].length; j++){
		//对arr2[i][j]赋值
	}
}
```

### 3. 动态定义多维数组

```java
//可以只定义多维数组的第一个维度的长度，后面维度的长度可以之后再定义
int[][] arr3 = new int[2][];
for(int i=0; i<arr3.length; i++){
	//对第二个维度再定义长度
    arr3[0] = new int[2];
	arr3[1] = new int[3];
}
```

### 4.多维数组的底层实现

从数组的底层运行机制上看，java没有多维数组。**二维数组可以简单的总结为：数组的引用指向一维数组，一维数组指向另一个一维数组**

- **原因：**java语言中数组类型是引用类型，因此数组变量其实是一个引用，这个引用指向真实的数组内存。并且数组元素的类型也可以是引用，如果数组元素的引用再次指向真实的数组内存，这种情形看上去就是我们通常说的多维数组了。

![image-20211127231748588](https://raw.githubusercontent.com/LSC-cong/Bolg/main/cloudimages/202111272317674.png)

```java
public class TwoArrary {
	public static void main(String[] args){
		//定义一个二维数组
		int[][] a;
        
		//把a当成一维数组进行初始化，初始化a是一个长度为4的数组
		//a数组的数组元素又是引用类型
		a=new int[4][];
		
		//把a数组当成一维数组，遍历a数组的每个元素
		for(int i=0,len=a.length;i<len;i++){
			System.out.println(a[i]);
		}
		
		//初始化a数组的第一个元素
		a[0]=new int[2];
		//访问a数组的第一个元素所指数组的第二个元素
		a[0][1]=6;
		//a数组的第一个元素是一个一维数组，遍历这个一维数组
		for(int i=0,len=a[0].length;i<len;i++){
			System.out.println(a[0][i]);
		}
	}
}
```



## （三）数组的遍历

### 1. 使用for循环

```java
//一维数组
int[] arr1 = {1,2,3,4,5};
for(int i=0; i<arr1.length; i++){
    System.out.println(arr[i]);
}
//多维数组
int[][] arr2 = {{1,2},
                {3,4,5}};
for(int i=0; i<arr2.length; i++){
    for(int j=0; j<arr2[i].length; j++){
        System.out.println(arr2[i][j]);
    }
}
```

### 2. 使用for each遍历

```java
//一维数组
int[] arr1 = {1,2,3,4,5};
for(int i : arr1){
    System.out.println(i);
}
//多维数组
int[][] arr2 = {{1,2},
              {3,4,5}};
for(int[] i : arr2){
    for(int j : i){
        System.out.println(j);
    }
}
```

## （四）Arrays工具类： java.util.Arrays

### 1.Arrays.copyOf(type[] original, int length)：type[] newarr

**这个方法将会复制原始数组original指定长度length的元素到一个新数组newarr**。其中 length 是新数组的长度。如果 length 小于 original 数组的长度，则新数组就是原数组的前面 length 个元素，如果 length 大于 original 数组的长度，则新数组的前面元索就是原数组的所有元素，后面补充 0（数值类型）、false（布尔类型）或者 null（引用类型）。

```java
String[] originArr = new String[]{"唐僧", "孙悟空", "猪八戒", "沙僧"};
String[] newArr2 = Arrays.copyOf(originArr, 3);
String[] newArr3 = Arrays.copyOf(originArr, 6);
//唐僧 孙悟空 猪八戒
//唐僧 孙悟空 猪八戒 沙僧	null null
```

### 2. Arrays.copyOfRange(type[] original, int start, int end)：type[] newarr

属于Arrays类的静态方法，可以通过类名直接调用，作用是复制指定strat索引到end索引的数组，注意，复制的数组元素是[start, end)，即包括start的索引，但不包括end索引对应的元素。

```java
String[] originArr = new String[]{"唐僧", "孙悟空", "猪八戒", "沙僧"};
String[] newArr = Arrays.copyOfRange(originArr, 1, 3);
//孙悟空 猪八戒
```

> 发现Arrays.copyOf()和Arrays.copyOfRange()方法的底层都是调用System.arraycopy()方法完成的。

### 3. Arrays.fill(type[] a, type val)：void

该方法将会把 a 数组的所有元素都赋值为 val。

### 4. Arrays.sort(type[] a)：void

该方法对 a 数组的数组元素进行排序。

```jaVA
//升序
Arrays.sort(scores);
//降序
Arrays.sort(a, Collections.reverseOrder());
```

### 5. Arrays.toString(type[] a)：String

该方法将一个数组转换成一个字符串。该方法按顺序把多个数组元素连缀在一起，多个数组元素使用英文逗号`,`和空格隔开。

```java
int[] arr = {1,2,3,4};
String s = Arrays.toString(arr);
System.out.println(s);
//[1, 2, 3, 4]
```

### 6.Arrays.equals(type[] a, type[] a2)：boolean 

如果 a1 数组和 a2 数组的长度相等，而且 a1 数组和 a2 数组的数组元素也一一相同，该方法将返回 true。

```java
double[] score1 = { 99, 100, 98.5, 96.5, 72 };
double[] score2 = new double[5];
score2[0] = 99;
score2[1] = 100;
score2[2] = 98.5;
score2[3] = 96.5;
score2[4] = 72;
double[] score3 = { 99, 96.5, 98.5, 100, 72 };
if (Arrays.equals(score1, score2)) {
    System.out.println("score1 数组和 score2 数组相等");
} else {
    System.out.println("score1 数组和 score2 数组不等");
}
if (Arrays.equals(score1, score3)) {
    System.out.println("score1 数组和 score3 数组相等");
} else {
    System.out.println("score1 数组和 score3 数组不等");
}
//score1 数组和 score2 数组相等
//score1 数组和 score3 数组不等
```



# 八、字符串

## （一）String

### 1. 定义

（1）直接定义

直接定义的字符串是Java中唯一不需要new就可以产生对象的途径,称之为**直接量**。

```java
String str = "Hello";
//或者
String str;
str = "Hello";
```

（2）直接定义

```java
//方式二 类定义
//String(String original)
String str1 = new String("Hello");
String str2 = new String(str1);//str1和str2的equals相等，但是==不等
//或者
//String(char[ ]value)
char arr[] = {'H','e','l','l','0'};
String str = new String(arr);//字符数组的内容已被复制为一个新的字符串,后续对字符数组的修改不会影响新创建的字符串
//或者
//String(char[] value,int offset,int count),offset 参数是子数组第一个字符的索引，count 参数指定子数组的长度。
char a[]={'H','e','l','l','o'};
String sChar=new String(a,1,4);

```

### 2. 对字符串的操作

#### (1)String和int的转换 、String和char [] 的转换

##### 1)String转int

```java
String str = "123";
int i = Integer.parseInt(str);//方式一
int i = Integer.valueOf(str).intValue();//方式二
```

##### 2)int转String

```java
int i = 123;
String s = String.valueOf(i);//方式一
String s = Integer.toString(i);//方式二
String s = "" + i;//方式三
```

##### 3）String转char、char []、String []

```java
String str = "123";
char cc = String.charAt(index);//定位到字符串的某个字符
char[] c = str.toCharArray();//字符串转换成字符数组
String[] s = str.split("");//字符串转换成字符串数组
```

##### 4）char []转String

```java
char[] arr = {'1','2','3'};

String string = String.valueOf('c');
String string = String.valueOf(new char[]{'1','2','3'});
String string = String.valueOf(arr);

String string = new String(new char[]{'1','2','3'}); 
String string = new String(arr);

String string = Character.toString('c');
String string = new Character('c').toString();

String string = "" + 'c';
```



#### (2)String的三个方法

##### 1)valueOf()

##### 2)parseXxx()

##### 3)toString()



#### (3)String拼接

##### 1)使用连接运算符"+"

​	字符串与字符串相连得到的结果是字符串;但是若字符串与其他数据类型相连,编译器会将其他数据类型转换成字符串形式

##### 2)使用concat()方法

concat()方法用于连接两个字符串

```java
String info = "三国演义和";
info = info.concat("西游记");
```



#### (4)String的重要方法

##### 1)获取字符串长度

```java
//获取字符串长度
String str = "abcd";
int len = str.length();
//获取数组长度
int[] arr = {1,2,3};
int len = arr.length;
//获取集合长度
ArrayList<Integer> arrlist = new ArrayList<>();
int len = arrlist.size();
```

##### 2)大小写转换

```java
String str="abcdef 我 ghijklmn";
System.out.println(str.toLowerCase());    // abcdef 我 ghijklmn
System.out.println(str.toUpperCase());    // ABCDEF 我 GHIJKLMN
```

##### 3)去除字符串中的空格

```java
String str = "你 hello 啊";
System.out.println(str.trim());//你hello啊
```

##### 4)提取子字符串

```java
//1. substring(int beginIndex) 形式,提取从索引位置开始至结尾处的字符串部分
String str = "我爱Java编程";
String result = str.substring(2);
System.out.println(result);    // Java编程

//2. substring(int beginIndex，int endIndex) 形式,提取位置 beginIndex 和位置 endIndex 位置之间的字符串部分.左闭右开
String str = "我爱Java编程";
String result = str.substring(2,6);
System.out.println(result);    // Java

```

##### 5)字符串分割

- "."和"|"都是转义字符,必须加"\\\\"
- 如果需要使用多个分隔符,可以用"|"作为连字符

```java
//1.str.split(String sign)
String Colors = "Red,Black,White,Yellow,Blue";
String[] arr1 = Colors.split(","); // 不限制元素个数
//输出为:
//Red
//Black
//White
//Yellow
//Blue

//2.str.split(String sign,int limit)
String[] arr2 = Colors.split(",", 3); // 限制元素个数为3,即分割后的结果只有三个元素
//输出为:
//Red
//Black
//White,Yellow,Blue
```

##### 6)字符串替换

```Java
//直接替换字符串中的所有字符--字符串.replace(String oldChar, String newChar)
String words = "hello java,hello php";
System.out.println(words.replace("hello","你好"));//你好 java,你好 php

//第一个参数是正则表达式
//将目标字符串中匹配某正则表达式的第一个子字符串替换成新的字符串,字符串.replaceFirst(String regex,String newChar)
//将目标字符串中匹配某正则表达式的所有子字符串替换成新的字符串,字符串.replaceAll(String regex,String newChar) 
String intro = "今天时星其天，外面时下雨天。妈米去买菜了，漏网在家写作业。语文作业时”其”写 5 行，数学使第 10 页。";
// 将文本中的所有"时"和"使"都替换为"是"
String newStrFirst = intro.replaceAll("[时使]", "是");
// 将文本中的所有"妈米"改为"妈妈"
String newStrSecond = newStrFirst.replaceAll("妈米", "妈妈");
// 将文本中的所有"漏网"改为"留我"
String newStrThird = newStrSecond.replaceAll("漏网", "留我");
// 将文本中第一次出现的"其"改为"期"
String newStrFourth = newStrThird.replaceFirst("[其]", "期");

//输出结果:今天是星期天，外面是下雨天。妈妈去买菜了，留我在家写作业。语文作业是”其”写 5 行，数学是第 10 页。

```

##### 7)字符串比较

- equals()方法----比较字符串的字面量是否相等
- equalsIgnoreCase()方法----忽视大小写判断两个字符串字面量是否相等
- compraeTo()方法----按字典顺序比较两个字符串的大小,基于各个字符的Unicode码来比较

```java
String str = "A";
String str1 = "a";
System.out.println("str.compareTo(str1)的结果是：" + str.compareTo(str1));
System.out.println("str1.compareTo(str)的结果是：" + str1.compareTo(str));
System.out.println("str1.compareTo('a')的结果是：" + str1.compareTo("a"));
/*str.compareTo(str1)的结果是：-32
  str1.compareTo(str)的结果是：32
  str1.compareTo('a')的结果是：0
 */
```

##### 8)字符串查找

- indexOf()方法----返回字符（串）在指定字符串中首次出现的索引位置，如果能找到，则返回索引值，否则返回 -1

```java
//str 表示指定字符串；value 表示待查找的字符（串）；fromIndex 表示查找时的起始索引
//str.indexOf(value)
//str.indexOf(value,int fromIndex)
String s = "Hello Java";
int size = s.indexOf('v');    // size的结果为8
```

- lastlndexOf() 方法----返回字符（串）在指定字符串中最后一次出现的索引位置，如果能找到则返回索引值，否则返回 -1

> **indexOf()和lastIndexOf()方法功能相似,前者从左往右,查找第一个出现的字符,后者从右往左,查找第一个出现的字符**

- charAt()方法----在字符串内,根据指定的索引查找字符

```java
String words = "today,monday,sunday";
System.out.println(words.charAt(0));    // 结果：t
System.out.println(words.charAt(1));    // 结果：o
System.out.println(words.charAt(8));    // 结果：n
```



## （二）StringBuffer和StringBulilder

### 1.StringBuffer类

#### (1)构造方法

- StringBuffer() 构造一个空的字符串缓冲区，并且初始化为 16 个字符的容量。
- StringBuffer(int length) 创建一个空的字符串缓冲区，并且初始化为指定长度 length 的容量。
- StringBuffer(String str) 创建一个字符串缓冲区，并将其内容初始化为指定的字符串内容 str，字符串缓冲区的初始容量为 16 加上字符串 str 的长度。

#### (2)追加字符串

```java
StringBuffer buffer = new StringBuffer("hello,");    // 创建一个 StringBuffer 对象
String str = "World!";
buffer.append(str);    // 向 StringBuffer 对象追加 str 字符串
System.out.println(buffer);    //hello,world!
```

#### (3)替换字符

```java
StringBuffer sb = new StringBuffer("hello");
sb.setCharAt(1,'E');
System.out.println(sb);    // 输出：hEllo
```

#### (4)反转字符串

```java
StringBuffer sb = new StringBuffer("1234");
sb.reverse();
System.out.println(sb);    // 输出：4321
```

#### (5)删除字符

##### 1)deleteCharAt(int Index)方法----用于移除指定位置的字符

```java
StringBuffer sb = new StringBuffer("abcde");
sb.deleteCharAt(2);
System.out.println(sb);    // 输出：abde
```

##### 2)delete(int start, int end)方法----用于移除序列中子字符串的字符

```java
StringBuffer sb = new StringBuffer("hello jack");
sb.delete(2,5);			   //左闭右开
System.out.println(sb);    // 输出：he jack
```

### 2.StringBuilder类

> 与StringBuffer类功能基本相似,方法也基本差不多

### 3.String、StringBuffer、StringBuilder对比

(1)String类是不可以变的类,即一旦一个String对象被创建后,包含在在这个对象中的字符序列是不可变的,直到这个对象被销毁

(2)StringBuffer和StringBuilder相似,但是**StringBuffer是线程安全的**,**StringBuilder不是线程安全的,所以性能略高**

(3)CharSequence 是一个定义字符串操作的接口，它只包括 length()、charAt(int index)、subSequence(int start, int end) 这几个 API。

![image-20211123220056827](https://raw.githubusercontent.com/LSC-cong/Bolg/main/cloudimages/202111232201950.png)

(4)总结

- **操作少量的数据使用 String。**
- **单线程操作大量数据使用 StringBuilder。**
- **多线程操作大量数据使用 StringBuffer。**

# 九、数字和日期

## (一)Math类的常用方法

### 1. 静态常量

```java
System.out.println("E 常量的值：" + Math.E);
System.out.println("PI 常量的值：" + Math.PI);
//E 常量的值：2.718281828459045
//PI 常量的值：3.141592653589793
```

### 2. 静态方法

#### (1)最大最小和绝对值

```java
System.out.println("10 和 20 的较大值：" + Math.max(10, 20));
System.out.println("15.6 和 15 的较小值：" + Math.min(15.6, 15));
System.out.println("-12 的绝对值：" + Math.abs(-12));
//10和20的较大值：20
//15.6和15的较小值：15.0
//-12的绝对值：12
```

#### (2)求整运算

```java
static double ceil(double a)	//向上取整
static double floor(double a)	//向下取整
static int round(float a)		//加上0.5,再向下取整
static long round(double a)		//加上0.5,再向下取整，然后强制转换为长整型
```

```java
float f1 = 1.2f;
float f2 = -1.2f;
System.out.println("ceil函数：" + Math.ceil(f1)+"||"+Math.ceil(f2));//向上取整
System.out.println("floor函数：" + Math.floor(f1)+"||"+Math.floor(f2));//向下取整
System.out.println("round函数：" + Math.round(f1)+"||"+Math.round(f2));//加上0.5,再向下取整
//ceil函数：2.0||-1.0
//floor函数：1.0||-2.0
//round函数：1||-1
```

#### (3)三角函数运算

#### (4)指数运算

```java
static double exp(double a)				//返回 e 的 a 次幂
static double pow(double a,double b)	//返回以 a 为底数，以 b 为指数的幂值
static double sqrt(double a)			//返回 a 的平方根
```

```java
System.out.println("4 的立方值：" + Math.pow(4, 3));
System.out.println("16 的平方根：" + Math.sqrt(16));
//4 的立方值：64.0
//16 的平方根：4.0
```

## (二)生成随机数

生成随机数有两种方法:**Math类的random()方法**和**Random类**

1.**Random()静态方法**：该构造方法使用一个和当前系统时间对应的数字作为种子数，然后使用这个种子数构造 Random 对象。**返回大于等于 0.0、小于 1.0 的 double 类型随机数。左闭右开**

```java
int min = 2; // 定义随机数的最小值
int max = 100; // 定义随机数的最大值
int s = (int) min + (int) (Math.random() * max);
System.out.println(s);
```

2.**Random类**：使用单个 long 类型的参数创建一个新的随机数生成器

| **方法**              | **说明**                                                     |
| :-------------------- | ------------------------------------------------------------ |
| boolean nextBoolean() | 生成一个随机的 boolean 值，生成  true 和 false 的值概率相等  |
| float nextFloat()     | 返回一个随机float值，数值介于  [0,1.0)，含 0 而不包含 1.0    |
| double nextDouble()   | 生成一个随机的double值，数值介于  [0,1.0)，含 0 而不包含 1.0 |
| int nextlnt()         | 生成一个随机的 int 值，数值任意，在int范围内即可             |
| int nextlnt(int n)    | 生成一个随机的 int 值，该值介于  [0,n)，包含 0 而不包含 n。  |
| long nextLong()       | 返回一个随机long值，数值任意，在long范围即可                 |

```java
Random random = new Random();
int num1 = random.nextInt();//产生任意int类型随机数
int num2 = random.nextInt(20);//产生[0,20)int类型随机数
float num3 = random.nextFloat();//产生[0.0,1.0)float类型随机数
long num4 = random.nextLong();//产生任意long类型随机数
double num5 = random.nextDouble();//产生[0.0,1.0)double类型随机数
boolean num6 = random.nextBoolean();//产生true false 随机布尔值
```

## （三）时间日期类

### 1.Data类

```java
Date date1 = new Date();    			 // 调用无参数构造函数
System.out.println(date1.toString());    // 输出：Wed May 18 21:24:40 CST 2016
```

### 2.Calendar类

​	**创建 Calendar 对象不能使用 new 关键字，因为 Calendar 类是一个抽象类，但是它提供了一个 getInstance() 方法来获得 Calendar类的对象。**

```java
Calendar calendar = Calendar.getInstance(); // 如果不设置时间，则默认为当前时间
calendar.setTime(new Date()); // 将系统当前时间赋值给 Calendar 对象
System.out.println("现在时刻：" + calendar.getTime()); // 获取当前时间
int year = calendar.get(Calendar.YEAR); // 获取当前年份
System.out.println("现在是" + year + "年");
```



# 十、内置包装类

## （一）装箱、拆箱——编译器

```java
//手动装拆箱
int m = 500;
Integer obj = new Integer(m);  // 手动装箱
int n = obj.intValue();  // 手动拆箱
//自动装拆箱
int m = 500;
Integer obj = m;  // 自动装箱
int n = obj;  // 自动拆箱
```



## （二）各种包装类

### 1.Object类

​	**Objeact类是Java类库中的特殊类，是所有类的父类**。当一个类被定义后，如果没有指定继承的父类，那么默认父类就是 Object 类。所有类都是Object的子类，则任何Java对象都可以调用Object类的方法。

| 方法                       | 说明                                                         |
| -------------------------- | ------------------------------------------------------------ |
| Object clone()             | 创建与该对象的类相同的新对象                                 |
| int hashCode()             | 返回该对象的散列码值                                         |
| **boolean equals(Object)** | **比较两对象是否相等**                                       |
| **String toString()**      | **返回该对象的字符串表示**                                   |
| **Class getClass()**       | **返回一个对象运行时的实例类**                               |
| void finalize()            | 当垃圾回收器确定不存在对该对象的更多引用时，对象垃圾回收器调用该方法 |
| void notify()              | 激活等待在该对象的监视器上的一个线程                         |
| void notifyAll()           | 激活等待在该对象的监视器上的全部线程                         |
| void wait()                | 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法前，导致当前线程等待 |

#### (1)toString()方法

```java
//toString（）方法
public class Person {
    private String name;
    private int age;
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    //重写了toString（）方法
    public String toString() {
        return "姓名：" + this.name + "：年龄" + this.age;
    }
    public static void main(String[] args) {
        Person per = new Person("C语言中文网", 30);// 实例化Person对象
        System.out.println("对象信息：" + per);// 打印对象调用toString()方法
    }
}
//对象信息：姓名：C语言中文网：年龄30
```

#### (2)equals()和==

- **== 的作用是判断两个对象的地址是否相等，即判断两个对象是否是同一个对象，**
  - 基本数据类型：比较的是值
  
  - 引用数据类型：比较的是内存地址
  
- **equals() 的作用是判断两个对象是否相等。**

  - **不可以用于基本数据类型的变量比较**

  - equals()方法属于Object类中的方法

  - **若类没有覆写该方法，则等价于 ==**

  - **若类覆写了该方法，一般覆写后的equals()方法用于判断两个对象的==字面量==是否相等。如：String类中的equals()方法**

#### (3)getClass()方法

​	**getClass() 方法返回对象所属的类，是一个 Class 对象。通过 Class 对象可以获取该类的各种信息，包括类名、父类以及它所实现接口的名字等。**在详见反射章节。



#### (4)接受任意引用类型的对象

**因为Object类是所有类的父类，即所有类的对象（包含了数组和接口类型）都可以向上转型为Object类对象，即一切的引用类型都可以使用Object接受。**因为 Object 类可以接收任意的引用数据类型，所以在很多的类库设计上都采用 Object 作为方法的参数，这样操作起来会比较方便。

> 如果存在适当的接口类型，那么参数，返回值和字段都应该使用接口类型。
> 如果你养成**使用接口类型引用对象**的习惯，你的程序将更加灵活。 如果没有合适的接口存在，则通过**实现类来引用对象**是完全合适的。

```java
interface A {
    public String getInfo();
}
class B implements A {
    public String getInfo() {
        return "Hello World!!!";
    }
}
public class ObjectDemo04 {
    public static void main(String[] args) {
        A a = new B();// 为接口实例化
        Object obj = a;// 对象向上转型
        A x = (A) obj;// 对象向下转型
        System.out.println(x.getInfo());//Hello World!!!
    }
}
```

```java
public class InterfaceTest {
    public static void main(String[] args) {
        PetInterface p = new Cat();
        p.talk();
        p.batheSelf();//无法调用 ，报错The method batheSelf() is undefined for the type PetInterface
        ((Cat)p).bathSelf();//向下转型，可正常调用执行
    }
}
interface PetInterface {                
    public void talk();
}
class Cat implements PetInterface {
    @Override
    public void talk() {
        System.out.println("Meow!");
    }
    public void batheSelf() {
        System.out.println("Cat bathing");
    }
}
```



### 2.Byte类

#### （1）Byte类的构造方法

```java
//Byte(byte b)
byte b = 5;
Byte bb = new Byte(b);

//Byte(String s)，必须是数值型的String变量
String s = "5";
Byte bb =  new Byte(s);
```

#### （2）Byte类的常用方法

| 方法                        | 功能                                                         | 用法                                              |
| --------------------------- | ------------------------------------------------------------ | ------------------------------------------------- |
| byte  byteValue()           | 以一个 byte 值返回 Byte 对象                                 | byte  bb = b.byteValue();                         |
| double  doubleValue()       | 以一个 double 值返回此 Byte 的值                             | double  bb = b.doubleValue();                     |
| int  intValue()             | 以一个 int 值返回此 Byte 的值                                | int  bb = b.intValue();                           |
| int  compareTo(Byte byte)   | 在数字上比较两个 Byte 对象                                   | int  c = b1.compareTo(b2); //结果是b1-b2          |
| byte  parseByte(String s)   | 将 String 型参数解析成等价的 byte 形式                       | String s = "11"; <br/>byte bbb = b1.parseByte(s); |
| String  toString()          | 返回表示此 byte 值的 String 对象                             |                                                   |
| Byte  valueOf(String s)     | 返回一个保持指定 String 所给出的值的 Byte 对象               | Byte bb = b.valueOf(s);                           |
| boolean  equals(Object obj) | 将此对象与指定对象比较，如果调用该方法的对象与 obj 相等 则返回 true，否则返回 false |                                                   |



### 3.Integer类

#### （1）Integer类的构造方法

```java
Integer integer1 = new Integer(100);    	// 以 int 型变量作为参数创建 Integer 对象
Integer integer2 = new Integer("100");    	// 以 String 型变量作为参数创建 Integer 对象
```

#### （2）Integer类的常用方法

| 方法                              | 返回值  | 功能                                                         |
| --------------------------------- | ------- | ------------------------------------------------------------ |
| byteValue()                       | byte    | 以 byte 类型返回该 Integer 的值                              |
| shortValue()                      | short   | 以 short 类型返回该 Integer 的值                             |
| intValue()                        | int     | 以 int 类型返回该 Integer 的值                               |
| toString()                        | String  | 返回一个表示该 Integer 值的 String 对象                      |
| equals(Object obj)                | boolean | 比较此对象与指定对象是否相等                                 |
| compareTo(Integer anotherlnteger) | int     | 在数字上比较两个 Integer 对象，如相等，则返回 0； 如调用对象的数值小于 anotherlnteger 的数值，则返回负值； 如调用对象的数值大于 anotherlnteger 的数值，则返回正值 |
| valueOf(String s)                 | Integer | 返回保存指定的 String 值的 Integer 对象                      |
| parseInt(String s)                | int     | 将数字字符串转换为 int 数值                                  |



### 4.Float类

#### （1）Float类的构造方法

```java
Float float1 = new Float(3.14145);    	// 以 double 类型的变量作为参数创建 Float 对象
Float float2 = new Float(6.5);    		// 以 float 类型的变量作为参数创建 Float 对象
Float float3 = new Float("3.1415");     // 以 String 类型的变量作为参数创建 Float 对象
```

#### （2）Float类的常用方法

| 方法                 | 返回值  | 功能                                                       |
| -------------------- | ------- | ---------------------------------------------------------- |
| byteValue()          | byte    | 以 byte 类型返回该 Float 的值                              |
| doubleValue()        | double  | 以 double 类型返回该 Float 的值                            |
| floatValue()         | float   | 以 float 类型返回该 Float 的值                             |
| intValue()           | int     | 以 int 类型返回该 Float 的值（强制转换为 int 类型）        |
| longValue()          | long    | 以 long 类型返回该 Float 的值（强制转换为 long 类型）      |
| shortValue()         | short   | 以 short 类型返回该 Float 的值（强制转换为 short 类型）    |
| isNaN()              | boolean | 如果此 Float 值是一个非数字值，则返回 true，否则返回 false |
| isNaN(float v)       | boolean | 如果指定的参数是一个非数字值，则返回 true，否则返回 false  |
| toString()           | String  | 返回一个表示该 Float 值的 String 对象                      |
| valueOf(String s)    | Float   | 返回保存指定的 String 值的 Float 对象                      |
| parseFloat(String s) | float   | 将数字字符串转换为 float 数值                              |



### 5.Double类

#### （1）Double类的构造方法

```java
Double double1 = new Double(5.456);   		// 以 double 类型的变量作为参数创建 Double 对象
Double double2 = new Double("5.456");       // 以 String 类型的变量作为参数创建 Double 对象
```

#### （2）Double类的常用方法

| 方法                  | 返回值  | 功能                                                        |
| --------------------- | ------- | ----------------------------------------------------------- |
| byteValue()           | byte    | 以 byte 类型返回该 Double 的值                              |
| doubleValue()         | double  | 以 double 类型返回该 Double 的值                            |
| fioatValue()          | float   | 以 float 类型返回该 Double 的值                             |
| intValue()            | int     | 以 int 类型返回该 Double 的值（强制转换为 int 类型）        |
| longValue()           | long    | 以 long 类型返回该 Double 的值（强制转换为 long 类型）      |
| shortValue()          | short   | 以 short 类型返回该 Double 的值（强制转换为 short 类型）    |
| isNaN()               | boolean | 如果此 Double 值是一个非数字值，则返回 true，否则返回 false |
| isNaN(double v)       | boolean | 如果指定的参数是一个非数字值，则返回 true，否则返回 false   |
| toString()            | String  | 返回一个表示该 Double 值的 String 对象                      |
| valueOf(String s)     | Double  | 返回保存指定的 String 值的 Double 对象                      |
| parseDouble(String s) | double  | 将数字字符串转换为 Double 数值                              |

### 6.Number类

​	**Number 是一个抽象类，也是一个超类（即父类）。Number 类属于 java.lang 包，所有的包装类（如 Double、Float、Byte、Short、Integer 以及 Long）都是抽象类 Number 的子类。**==**Boolean和Character类不是Number的子类**==。关系如下：

![image-20211126194857495](https://raw.githubusercontent.com/LSC-cong/Bolg/main/cloudimages/202111261948605.png)

### 7.Character类

#### （1）Character类的构造方法

```java
Character character = new Character('S');//以 char 类型的变量作为参数创建 Character 对象
```

#### （2）Character类的常用方法

| 方法                                       | 描述                                                         |
| ------------------------------------------ | ------------------------------------------------------------ |
| void Character(char value)                 | 构造一个新分配的 Character 对象，用以表示指定的 char 值      |
| char charValue()                           | 返回此 Character 对象的值，此对象表示基本 char 值            |
| int compareTo(Character anotherCharacter)  | 根据数字比较两个 Character 对象                              |
| boolean equals(Character anotherCharacter) | 将此对象与指定对象比较，当且仅当参数不是 null，而 是一个与此对象 包含相同 char 值的 Character 对象时， 结果才是 true |
| boolean isDigit(char ch)                   | 确定指定字符是否为数字，如果通过 Character. getType(ch) 提供的字 符的常规类别类型为 DECIMAL_DIGIT_NUMBER，则字符为数字 |
| boolean isLetter(int codePoint)            | 确定指定字符（Unicode 代码点）是否为字母                     |
| boolean isLetterOrDigit(int codePoint)     | 确定指定字符（Unicode 代码点）是否为字母或数字               |
| boolean isLowerCase(char ch)               | 确定指定字符是否为小写字母                                   |
| boolean isUpperCase(char ch)               | 确定指定字符是否为大写字母                                   |
| char toLowerCase(char ch)                  | 使用来自 UnicodeData 文件的大小写映射信息将字符参数转换为小写 |
| char toUpperCase(char ch)                  | 使用来自 UnicodeData 文件的大小写映射信息将字符参数转换为大写 |

### 8.Boolean类

#### （1）Boolean类的构造方法

```java
Boolean(boolean boolValue);//以 boolean 类型的变量作为参数创建 Boolean 对象

//以 String 类型的变量作为参数创建 Boolean 对象；
//判断boolString是否满足  ((boolString != null) && boolString.equalsIgnoreCase("true"))  若满足则为true，否则为false
Boolean(String boolString);
```

#### （2）Boolean类的常用方法

| 方法                   | 返回值  | 功能                                                         |
| ---------------------- | ------- | ------------------------------------------------------------ |
| booleanValue()         | boolean | 将 Boolean 对象的值以对应的 boolean 值返回                   |
| equals(Object obj)     | boolean | 判断调用该方法的对象与 obj 是否相等。当且仅当参数不是 null，且与调用该 方法的对象一样都表示同一个 boolean 值的 Boolean 对象时，才返回 true |
| parseBoolean(String s) | boolean | 将字符串参数解析为 boolean 值                                |
| toString()             | string  | 返回表示该 boolean 值的 String 对象                          |
| valueOf(String s)      | boolean | 返回一个用指定的字符串表示的 boolean 值                      |

### 9.System类

#### （1）静态成员变量

​	**System 类有 3 个静态成员变量，分别是 PrintStream out、InputStream in 和 PrintStream err。**

```java
System.out.println("请输入字符，按回车键结束输入:");
int c;
try {
    c = System.in.read();    // 读取输入的字符
    while(c != '\r') {    // 判断输入的字符是不是回车
        System.out.print((char) c);    // 输出字符
        c = System.in.read();
    }
} catch(IOException e) {
    System.out.println(e.toString());
} finally {
    System.err.println();
}
```

#### （2）静态成员方法

##### 1）currentTimeMillis()方法

```java
long start = System.currentTimeMillis();//该方法的作用是返回当前的计算机时间
for(int i = 0;i < 100000000;i++) {
    int temp = 0;
}
long end = System.currentTimeMillis();
long time = end - start;
System.out.println("程序执行时间" + time + "秒");
```

##### 2）exit()方法

该方法的作用是终止当前正在运行的 Java 虚拟机。

##### 3）gc()方法

该方法的作用是请求系统进行垃圾回收，完成内存中的垃圾清除。



## （三）方法总结

| 方法                              | 功能                                                         | 示例                                                         |
| --------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| boolean   xxx.equals(yyy)         | Object类中判断xxx和yyy**地址是否相同**；包装类中判断xxx和yyy**类型是否相同且值是否相等**；String类以及一些重写equals()方法的类中判断**字面量是否相等** | Integer i = new Integer(3);     int i1 = 3;    **boolean b = i.equals(i1);** |
| int  Integer.intValue()           | 把Integer类型变成int类型                                     | Double d = new Double(2.1);     **float f = d.floatValue();** |
| int  Integer.parseInt(String s)   | 把数值型的String类型转化为int类型                            | **int a = Integer.parseInt("1234");**                        |
| Integer Integer.valueOf(String s) | 把数值型的String类型转化为Integer类型                        | **Integer b = Integer.valueOf("1234");**                     |
| String  xxx.toString()            | 把一个引用类型xxx转化为String字符串类型                      | Integer a = new Integer(123);   **String b =a.toString();**  |









