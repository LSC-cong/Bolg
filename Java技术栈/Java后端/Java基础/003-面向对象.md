# 一、类与对象

## （一）面向对象的三大特征

### 1. 封装

#### （1）特点

- **封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。**==封装的目的在于保护信息==**。
- 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

- Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。

#### （2）优点

- **保护类中的信息，它可以阻止在外部定义的代码随意访问内部代码和数据。**
- **隐藏细节信息**，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。
- **有助于建立各个系统之间的松耦合关系，提高系统的独立性。**当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。例如 U 盘，不管里面的存储方式怎么改变，只要 U 盘上的 USB 接口不变，就不会影响用户的正常操作。
- **提高软件的复用率，降低成本。**每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。例如，一个 U 盘可以在多台电脑上使用。

### 2. 继承

#### （1）特点

- **程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系**。
- **不同类型的对象，内部存在一定的共性，继承是使用已存在的类的定义作为基础建立新类。通过继承提高代码的重用性。程序的可维护性，提高开发效率。**
- **C++支持多继承，多继承就是一个子类可有多个父类**。多继承会引起很多冲突问题，因此现在很多面向对象的语言都不支持多继承。**Java 语言是单继承的，即只能有一个父类，但 Java 可以实现多个接口**。接口类似于类，但接口的成员没有执行体，可以防止多继承所引起的冲突问题。

#### （2）局限性

- 继承是侵入性的。只要继承，就必须拥有父类的属性和方法。
- 降低代码灵活性。子类拥有父类的属性和方法后多了些约束。
- 增强代码耦合性（开发项目的原则为高内聚低耦合）。当父类的常量、变量和方法被修改时，需要考虑子类的修改，有可能会导致大段的代码需要重构。

### 3. 多态

#### （1）特点

- 面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。
- 父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果简单来说就是**同一个事件发生在不同的对象上会产生不同的结果。**
- 封装和继承就是为多态做准备的，多态的三个前提条件：**继承父类、重写父类的方法、父类的引用指向子类对象（即向上转型）。**

#### （2）实现方式

- 接口实现

- 继承父类**方法重写**

- 同一类中进行**方法重载**

## （二）类的定义

```java
[public][abstract|final]class<class_name>[extends<class_name>][implements<interface_name>] {
    // 定义属性部分
    <property_type> <property1>;
    <property_type> <property2>;
    <property_type> <property3>;
    …
    // 定义方法部分
    function1();
    function2();
    function3();
    …
}
```

## （三）对象的创建

> - 使用 new 关键字或 Class 对象的 newInstance() 方法创建对象时，都会调用类的构造方法。
> - 使用 Class 类的 newInstance() 方法创建对象时，会调用类的默认构造方法，即无参构造方法。
> - 使用 Object 类的 clone() 方法创建对象时，不会调用类的构造方法，它会创建一个复制的对象，这个对象和原来的对象具有不同的内存地址，但它们的属性值相同。

### 1.使用new关键字

```java
类名 对象名 = new 类名()；
```

- 创建匿名对象
  - 每次 new 都相当于开辟了一个新的对象，并开辟了一个新的物理内存空间。如果一个对象只需要使用唯一的一次，就可以使用匿名对象，实际开发中匿名对象常常作为实际参数传递。
  - 匿名对象就是没有给出名字的对象，是一种简写的形式，一般只使用一次。而且匿名对象只在堆内存中开辟空间，不存在栈内存的引用。

````java
new Person("张三", 30).toString(); // 匿名对象
````

- 不同的方式定义字符串时堆和栈的变化
  - `String a;` 只是在栈中创建了一个 String 类的对象引用变量 a。
  - `String a = "C语言中文网";`在栈中创建一个 String 类的对象引用变量 a，然后查找栈中有没有存放“C语言中文网”，如果有则直接指向“C语言中文网"，如果没有，则将”C语言中文网“存放进栈，再指向。
  - `String a = new String("C语言中文网");`不仅在栈中创建一个 String 类的对象引用变量 a，同时也在堆中开辟一块空间存放新建的 String 对象“C语言中文网”，变量 a 指向堆中的新建的 String 对象”C语言中文网“。

> 堆是用来存放由 new 创建的对象和数组，即动态申请的内存都存放在堆区。栈是用来存放在方法中定义的一些基本类型的变量和对象的引用变量。



### 2.调用newlnstance()方法

在 Java 中，可以使用 java.lang.Class 或者 java.lang.reflect.Constuctor 类的 newlnstance() 实例方法来创建对象

```java
Class Class类对象名称 = Class.forName(要实例化的类全称);
要实例化的类名 对象名 = (要实例化的类名)Class类对象名称.newInstance();
```

### 3.调用对象的clone()方法

该方法不常用，使用该方法创建对象时，要**实例化的类必须继承 java.lang.Cloneable 接口**。 

```java
类名对象名 = (类名)已创建好的类对象名.clone();
```

### 4.调用readObject() 方法

调用 java.io.ObjectlnputStream 对象的 readObject() 方法

```java
public class Student implements Cloneable {
    // 实现 Cloneable 接口
    private String Name;    // 学生名字
    private int age;    // 学生年龄
    public Student(String name,int age) {
        // 构造方法
        this.Name = name;
        this.age = age;
    }
    public Student() {
        this.Name = "name";
        this.age = 0;
    }
    public String toString() {
        return"学生名字："+Name+"，年龄："+age;
    }
    public static void main(String[] args)throws Exception {
        // 使用new关键字创建对象
        Student student1 = new Student("小刘",22);
        System.out.println(student1);

        // 调用 java.lang.Class 的 newInstance() 方法创建对象
        Class c1 = Class.forName("Student");
        Student student2 = (Student)c1.newInstance();
        System.out.println(student2);

        // 调用对象的 clone() 方法创建对象
        Student student3 = (Student)student2.clone();
        System.out.println(student3);
    }
}
```

### 5.隐式的的创建对象

- String strName = "strValue"，其中的“strValue”就是一个 String 对象，由 Java 虚拟机隐含地创建。

- 字符串的“+”运算符运算的结果为一个新的 String 对象

```java
String str1 = "Hello";
String str2 = "Java";
String str3 = str1+str2;    // str3引用一个新的String对象
```

- 当 Java 虚拟机加载一个类时，会隐含地创建描述这个类的 Class 实例。
  - 类的加载是指把类的 .class 文件中的二进制数据读入内存中，把它存放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构

> 注意：无论釆用哪种方式创建对象，Java 虚拟机在创建一个对象时都包含以下步骤：
>
> - 给对象分配内存。
> - 将对象的实例变量自动初始化为其变量类型的默认值。
> - 初始化对象，给实例变量赋予正确的初始值。

# 二、成员变量与局部变量

```java
[public|protected|private][static][final]<type><variable_name>
/*
各参数的含义如下。
public、protected、private：用于表示成员变量的访问权限。
static：表示该成员变量为类变量，也称为静态变量。
final：表示将该成员变量声明为常量，其值无法更改。
type：表示变量的类型。
variable_name：表示变量名称。
*/
```

> 初始化的默认值如下：
>
> - 整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。
> - 单精度浮点型（float）的基本类型变量的默认值为 0.0f。
> - 双精度浮点型（double）的基本类型变量的默认值为 0.0d。
> - 字符型（char）的基本类型变量的默认值为 “\u0000”。
> - 布尔型的基本类型变量的默认值为 false。
> - 数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。

## （一）成员变量

又叫成员属性，定义了类的属性，作用域为整个类

## （二）局部变量

- **在方法体内可以定义本方法所使用的变量，这种变量是局部变量**。它的生存期与作用域是在本方法内，也就是说，**局部变量只能在本方法内有效或可见，离开本方法则这些变量将被自动释放。**
- **在方法体内定义变量时，变量前不能加修饰符**。局部变量在使用前必须明确赋值，否则编译时会出错。



# 三、成员方法

​	**声明成员方法可以定义类的行为**，行为表示一个对象能够做的事情或者能够从一个对象取得的信息。**类的各种功能操作都是用方法来实现的，属性只不过提供了相应的数据**。==**一个完整的方法通常包括  方法返回值类型、方法名称、方法参数、方法主体**==

```java
public class Test {
    [public|private|protected][static]<void|return_type><method_name>([paramList]) {
        // 方法体
    }
}
```

### 形参与实参

- **形参**是定义方法时参数列表中出现的参数，实参是调用方法时为方法传递的参数

- **形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元**。因此，形参只有在方法内部有效，方法调用结束返回主调方法后则不能再使用该形参变量。
- **实参可以是常量、变量、表达式、方法等，无论实参是何种类型的量，在进行方法调用时，它们都必须具有确定的值，以便把这些值传送给形参**。因此应预先用赋值、输入等办法使实参获得确定值。

# 四、注释

## （一）类注释

类注释一般必须放在所有的“import”语句之后，类定义之前，主要声明该类可以做什么，以及创建者、创建日期、版本和包名等一些信息。一般来说，创建人，创建时间，类描述是必要的

```java
/**
 * @projectName（项目名称）: project_name
 * @package（包）: package_name.file_name
 * @className（类名称）: type_name
 * @description（类描述）: 一句话描述该类的功能
 * @author（创建人）: user 
 * @createDate（创建时间）: datetime  
 * @updateUser（修改人）: user 
 * @updateDate（修改时间）: datetime
 * @updateRemark（修改备注）: 说明本次修改内容
 * @version（版本）: v1.0
 */
```

## （二）方法注释

方法注释必须紧靠在方法定义的前面，**主要声明方法参数、返回值、异常等信息**。

```java
/**
* @description 方法描述：描述方法的功能
* @param 变量描述：对当前方法的参数部分添加一个说明，可以占据多行。一个方法的所有 @param 标记必须放在一起。
* @return 返回类型描述：对当前方法添加返回值部分，可以跨越多行。
* @throws 异常类描述：表示这个方法有可能抛出异常。有关异常的详细内容将在第 10 章中讨论。
*/
```

## （三）字段注释

字段注释在定义字段的前面，用来描述字段的含义。



# 五、this关键字

this 关键字是Java常用的关键字。主要有三个应用：

### 1.this调用当前对象中的成员变量；

- 正常情况下引用属性都是以  **对象.属性** 的形式。但是**当成员变量和局部变量重名时，为了区分，在方法中使用this，表示该方法所在类中的成员变量。this表示的是当前类的对象**

```java
class hello{
    public static void main(String [] args){
        //Person p1 = new Person(张三",20,"男"); //调用有参构造函数，对成员变量进行初始化
        Person p1 = new Person(); //调用无参构造函数，使用setXxx()方法对成员变量进行初始化赋值，也可以
        p1.setAge(20);
        p1.setName("张三");
        p1.setGender("男");
        System.out.println(""+p1.getName()+" 今年"+p1.getAge()+"岁 性别为："+p1.getGender());
    }
}
class Person{
    private String name;
    private int age;
    private String gender;
    Person(){}
    Person(String name,int age,String gender){
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
    public void setName(String name){
        this.name = name;//this表示当前对象的实例，即p1，this.name表示p1实例中的name，是成员变量，name表示所在方法中的方法参数name，是局部变量
    }
    public String getName(){
        return name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return age;
    }
    public void setGender(String gender){
        this.gender = gender;
    }
    public String getGender(){
        return gender;
    }
}
```

### 2.this调用当前对象中的其他成员方法；

- this 关键字最大的作用就是让类中一个方法，访问该类中的另一个方法，而不用重新创建一个新的实例。

- this 可以代表任何对象，当 this 出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，**它所代表的只能是当前类的实例**。只有当这个方法被调用时，它所代表的对象才被确定下来，谁在调用这个方法，this 就代表谁。
- 对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用 this 关键字，则这个关键字就无法指向合适的对象。**所以，static 修饰的方法中不能使用 this 引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。**

```java
public class DogTest{
    public static void main(String[] args) {
        // 创建Dog对象
        Dog dog = new Dog();
        // 调用Dog对象的run()方法
        dog.run();
    }
}
class Dog {
    // 定义一个jump()方法
    public void jump() {System.out.println("正在执行jump方法");}
    // 定义一个run()方法，run()方法需要借助jump()方法
    public void run() {
        //方式一，不使用this，重新创建一个新的类，再调用jump()方法
        //Dog d = new Dog();
        //d.jump();
        //方式二，使用this，this表示当前Dog类的实例（如dog）
        //因为当程序调用 run( ) 方法时，一定会提供一个 Dog 对象，这样就可以直接使用这个已经存在的 Dog 对象，而无须重新创建新的 Dog 对象了。因此需要在 run() 方法中获得调用该方法的对象，通过 this 关键字就可以满足这个要求。
        this.jump();
        System.out.println("正在执行 run 方法");
    }
}
```



### 3.this()调用当前对象中的其他构造方法

> 一个类中有多个构造函数，有时候需要在一个构造函数中调用其他的构造函数，避免代码重复，使用this关键字。
>
> 在java编程思想中有这样一段话：通常写this的时候，都是指“这个对象”或者“当前对象”，而且它本身表示对当前对象的引用。在构造器中，如果为this添加了参数列表，那么就有不同的含义。这将产生对符合此参数列表的某个构造器的明确调用；这样调用其他构造函数就有了直接的途径。

- **this()只能放在构造方法中，不能放在普通方法中，要放在构造方法的首行，而且一个构造方法内只能调用一个构造方法**；
  - 规定放在构造方法首行的原因是，不会使得  this(xxx，xxx)  调用的其他有参构造影响当前有参构造的赋值。

```java
Person(String name){
    this.name = name;
}
Person(String name,int age,String gender){
    //this("lsc");调用的是Person(String name)构造参数，对name进行初始化，
    this("lsc");//放在这里不影响后面，第二条语句this.name = name;对name变量的初始化，因为this("lsc")的效果会被覆盖。
    this.name = name;
    this.age = age;
    this.gender = gender;
    //this("lsc");//放在这里会覆盖掉当前构造函数的初始化结果，不好。
}
```

- **()中可以有参数，就是调用指定的有参构造**





# 六、static关键字

static修饰的**变量**称为静态变量、类变量；**常量**称为静态常量；**方法**称为静态方法、类方法。它们统称为**静态成员**。

- 静态成员不依赖于类的特定实例，被类的所有实例共享，就是说 static 修饰的方法或者变量不需要依赖于对象来进行访问，只要这个类被加载，Java虚拟机就可以根据类名找到它们。
- static 修饰的变量和方法，从属于类。
- 普通变量和方法，从属于对象。

## （一）静态变量

### 1. 特点

- **==静态变量可以被类的所有实例共享==，因此静态变量可以作为实例之间的共享数据，增加实例之间的交互性。**
- 如果类的所有实例都包含一个相同的常量属性，则可以把这个属性定义为静态常量类型，从而节省内存空间。例如，在类中定义一个静态常量 PI。
- 静态变量可以**直接访问、通过类名访问**或者**通过实例化对象访问**

### 2. 静态变量与普通变量

#### （1）静态变量

- 运行时，Java 虚拟机只为静态变量分配一次内存，在加载类的过程中完成静态变量的内存分配。
- 在类的内部，可以在任何方法内直接访问静态变量。
- 在其他类中，可以通过类名访问该类中的静态变量。

#### （2）实例变量

- 每创建一个实例，Java 虚拟机就会为实例变量分配一次内存。

## （二）静态方法

### 静态方法与普通方法

- 静态方法不需要通过它所属的类的任何实例就可以被调用，因此在静态方法中不能使用 this 关键字，也不能直接访问所属类的实例变量和实例方法，但是可以直接访问所属类的静态变量和静态方法。另外，和 this 关键字一样，super 关键字也与类的特定实例相关，所以在静态方法中也不能使用 super 关键字。
- 访问静态方法，可以**直接调用静态方法**、**通过类名调用静态方法**或者**通过实例化对象访问也行**；访问非静态方法时，需要通过实例对象来访问。

## （三）静态代码块

**静态代码块指 Java 类中的 static{ } 代码块，主要用于初始化类，为类的静态变量赋初始值，提升程序性能。**

### 特点

- 静态代码块类似于一个方法，但它不可以存在于任何方法体中。
- 静态代码块可以置于类中的任何地方，类中可以有多个静态初始化块。 
- Java 虚拟机在加载类时执行静态代码块，所以很多时候会将一些只需要进行一次的初始化操作都放在 static 代码块中进行。
- **如果类中包含多个静态代码块，则 Java 虚拟机将按它们在类中出现的顺序依次执行它们，每个静态代码块只会被执行一次。**
- 不能在static 环境中访问非 static 变量

```java
public class StaticCode {
    public static int count = 0;//0
    {//3  //4
        count++;
        System.out.println("非静态代码块 count=" + count);
    }
    static {//1
        count++;
        System.out.println("静态代码块1 count=" + count);
    }
    static {//2
        count++;
        System.out.println("静态代码块2 count=" + count);
    }
    public static void main(String[] args) {
        System.out.println("*************** StaticCode1 执行 ***************");
        StaticCode sct1 = new StaticCode();//3
        System.out.println("*************** StaticCode1 执行结束 ***************");

        System.out.println("*************** StaticCode2 执行 ***************");
        StaticCode sct2 = new StaticCode();//4
        System.out.println("*************** StaticCode2 执行结束 ***************");

    }
}
/*
静态代码块1 count=1
静态代码块2 count=2
*************** StaticCode1 执行 ***************
非静态代码块 count=3
*************** StaticCode2 执行 ***************
非静态代码块 count=4
*************** main函数结束 ***************
*/
```



# 七、final关键字

final 应用于类、方法和变量时意义是不同的，但本质是一样的，都表示不可改变。

## （一）修饰变量

### 1.修饰基本变量

**final 修饰的变量即成为常量，只能赋值一次，**但是 final 所修饰局部变量和成员变量有所不同。==**使用 final 声明变量时，要求全部的字母大写**==

1. final 修饰的局部变量必须使用之前被赋值一次才能使用。
2. final 修饰的成员变量在声明时没有赋值的叫“空白 final 变量”。空白 final 变量必须在构造方法或静态代码块中初始化。

> 注意：final 修饰的变量不能被赋值这种说法是错误的，严格的说法是，final 修饰的变量不可被改变，一旦获得了初始值，该 final 变量的值就不能被重新赋值。

### 2.final 修饰基本类型变量和引用类型变量的区别

当**使用 final 修饰基本类型变量**时，不能对基本类型变量重新赋值，因此基本类型变量不能被改变。 但**对于引用类型变量而言**，它保存的仅仅是一个引用，final **只保证这个引用类型变量所引用的地址不会改变，即一直引用同一个对象，但这个对象完全可以发生改变。**

```java
class Person {
    private int age;
    public Person(int age) {    // 有参数的构造器
        this.age = age;
    }
    // 省略了 age 的 setter 和 getter 方法
}
public class FinalReferenceTest {
    public static void main(String[] args) {
        final int[] iArr = { 5, 6, 12, 9 };// final修饰数组变量，iArr是一个引用变量
        System.out.println(Arrays.toString(iArr));
        Arrays.sort(iArr);// 对数组元素进行排序，合法
        System.out.println(Arrays.toString(iArr));
        iArr[2] = -8;// 对数组元素赋值，合法
        System.out.println(Arrays.toString(iArr));
        iArr = null;// 下面语句对iArr重新赋值,非法！！！
        final Person p = new Person(45);// final修饰Person变量，p是一个引用变量
        p.setAge(23);// 改变Person对象的age实例变量，合法
        System.out.println(p.getAge());
        p = null;// 下面语句对P重新赋值，非法！！！
    }
}
```

## （二）修饰方法

**final 修饰的方法不可被重写**，如果不希望子类重写父类的某个方法，则可以使用 final 修饰该方法。

- **对于一个 private 方法，因为它仅在当前类中可见，其子类无法访问该方法，所以子类无法重写该方法**——如果子类中定义一个与父类 private 方法有相同方法名、相同形参列表、相同返回值类型的方法，也不是方法重写，只是重新定义了一个新方法。

```java
//父类是public方法  出现问题
public class FinalMethodTest {
    public final void test() {
    }
}
class Sub extends FinalMethodTest {
    // 下面方法定义将出现编译错误，不能重写final方法
    public void test() {
    }
}
 //父类是private方法  没有问题
public class PrivateFinalMethodTest {
    private final void test() {
    }
}
class Sub extends PrivateFinalMethodTest {
    // 下面的方法定义不会出现问题
    public void test() {
    }
}
```

- final 修饰的方法仅仅是不能被重写，并不是不能被重载，因此下面程序完全没有问题。

```java
public class FinalOverload {
    // final 修饰的方法只是不能被重写，完全可以被重载
    public final void test(){}
    public final void test(String arg){}
}
```

## （三）修饰类

**final 修饰的类不能被继承。**当子类继承父类时，将可以访问到父类内部数据，并可通过重写父类方法来改变父类方法的实现细节，这可能导致一些不安全的因素。为了保证某个类不可被继承，则可以使用 final 修饰这个类。

```java
final class SuperClass{}
class SubClass extends SuperClass{}//编译错误
```



# 八、main函数

**main函数是java应用程序的入口方法：**

- **访问控制权限必须是共有的public**
- **main()方法是静态的**，如果要在 main() 方法中调用本类中的其他方法，则该方法也必须是静态的，否则需要先创建本类的实例对象，然后再通过对象调用成员方法。
- **main() 方法没有返回值，只能使用 void。**
- **main() 方法具有一个字符串数组参数，用来接收执行 Java 程序的命令行参数**。命令行参数作为字符串，按照顺序依次对应字符串数组中的元素。
- **main() 方法定义必须是`public static void main(String[] args)`。**args是字符串数组参数名，可以为任意。
- **一个类只能有一个 main() 方法**。



# 九、构造函数与析构函数

## （一）构造函数

构造方法是一种特殊的方法，用于初始化一个新的对象。Java每个类都有一个默认的无参构造方法，并且可以多个构造方法。

- 构造函数名必须与类名相同
- 可以有0个或多个参数；每个类可以具有多个构造方法，但要求它们各自包含不同的方法参数。（基于方法重载）
- 没有任何返回值，包括void；构造函数的默认返回类型就是对象类型本身，而且也不需要使用return，因为构造方法的返回值是隐式的
- 只能与new运算符结合使用

> 注意：类的构造方法不是要求必须定义的。如果在类中没有定义任何一个构造方法，则 Java 会自动为该类生成一个默认的构造方法。默认的构造方法不包含任何参数，并且方法体为空。如果类中显式地定义了一个或多个构造方法，则 Java 不再提供默认构造方法。

## （二）析构函数

析构方法与构造方法相反，**当对象脱离其作用域时（例如对象所在的方法已调用完毕），系统自动执行析构方法**。**析构方法往往用来做清理垃圾碎片的工作**，例如在建立对象时用 new 开辟了一片内存空间，应退出前在析构方法中将其释放。

- 垃圾回收器是否会执行该方法以及何时执行该方法，都是不确定的。
- finalize() 方法有可能使用对象复活，使对象恢复到可触及状态。
- 垃圾回收器在执行 finalize() 方法时，如果出现异常，垃圾回收器不会报告异常，程序继续正常运行。



# 十、包

- package 定义语句应该放在源文件的第一行，**在每个源文件中只能有一个包定义语句**。

- import 可以向某个 Java 文件中导入指定包层次下的某个类或全部类。import 语句位于 package 语句之后，类定义之前。**一个 Java 源文件只能包含一个 package 语句，但可以包含多个 import 语句。**

>注意：如果在源文件中没有定义包，那么类、接口、枚举和注释类型文件将会被放进一个无名的包中，也称为默认包。在实际企业开发中，通常不会把类定义在默认包下。

```java
//Student.java文件
package com.dao;//包定义
public class Student {
    public static String[] GetAll() {
        String[] namelist = {"李潘","邓国良","任玲玲","许月月","欧阳娜","赵晓慧"};
        return namelist;
    }
}
//Test.java文件
package com.test;//包定义
import com.dao.Student;//导入指定包下的类
public class Test {
    public static void main(String[] args) {
        System.out.println("学生信息如下：");
        for(String str:Student.GetAll()) {
            System.out.println(str);
        }
    }
}
```

| 系统包                | 说明                                                         |
| --------------------- | ------------------------------------------------------------ |
| java.lang             | Java 的核心类库，包含运行 Java 程序必不可少的系统类，如基本数据类型、基本数学函数、 字符串处理、异常处理和线程类等，系统默认加载这个包 |
| java.io               | Java 语言的标准输入/输出类库，如基本输入/输出流、文件输入/输出、过滤输入/输出流等 |
| java.util             | 包含如处理时间的 Date 类，处理动态数组的 Vector 类，以及 Stack 和 HashTable 类 |
| java.awt              | 构建图形用户界面（GUI）的类库，低级绘图操作 Graphics 类、图形界面组件和布局管理 （如 Checkbox 类、Container 类、LayoutManger 接口等），以及用户界面交互控制和事 件响应（如 Event 类） |
| java.awt.image        | 处理和操纵来自网上的图片的 Java 工具类库                     |
| java.wat.peer         | 很少在程序中直接用到，使得同一个 Java 程序在不同的软硬件平台上运行 |
| java.net              | 实现网络功能的类库有 Socket 类、ServerSocket 类              |
| java.lang.reflect     | 提供用于反射对象的工具                                       |
| java.util.zip         | 实现文件压缩功能                                             |
| java.awt.datatransfer | 处理数据传输的工具类，包括剪贴板、字符串发送器等             |
| java.sql              | 实现 JDBC 的类库                                             |
| java.rmi              | 提供远程连接与载入的支持                                     |
| java. security        | 提供安全性方面的有关支持                                     |

# 十一、封装与继承

## （一）封装

封装将类的某些信息隐藏在类内部，不允许外部程序直接访问，只能通过该类提供的方法来实现对隐藏信息的操作和访问

- 修改属性的可见性来限制对属性的访问，一般设为 private。
- 为每个属性创建一对赋值（setter）方法和取值（getter）方法，一般设为 public，用于属性的读写。
- 在赋值和取值方法中，加入属性控制语句（对属性值的合法性进行判断）。

```java
public class Employee {
    private String name; // 姓名
    private int age; // 年龄
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    //属性控制语句
    public void setAge(int age) {
        // 对年龄进行限制
        if (age < 18 || age > 40) {
            System.out.println("年龄必须在18到40之间！");
            this.age = 20; // 默认年龄
        } else {
            this.age = age;
        }
    }
}
```

## （二）继承

```java
<修饰符>  class  子类名  extends  父类名{}
```

> **类的继承不改变类成员的访问权限**，也就是说，如果父类的成员是private、public、protected或default，它的子类仍具有相应的这些特性；并且**子类不能获得父类的构造方法。**

## （三）super关键字

super关键字 可以用来访问父类的构造方法、普通方法和属性。具体来说：

- **在子类的构造方法中显式的调用父类构造方法**
- **访问父类的成员方法和变量。**

### 1.super调用父类构造方法

如果一个类没有写任何的构造方法，JVM会生成一个默认的无参构造方法。存在继承关系时，在子类的构造方法中第一条语句默认是调用父类的无参构造方法，即`super();`但是一般可以省略不写。但是如果父类定义了有参的构造方法，那么JVM就不会再生成无参构造方法，所以在继承关系中出现这种情况，**需要通过super在子类的构造方法中显式地调用父类的构造方法**。`super(参数列表);`表示父类的构造方法， 必须是在子类构造方法的方法体的第一行。或者，为了避免出错**，当父类定义多个构造方法时，也要显式的定义父类的无参构造方法**

### 2.super访问父类的成员方法和变量

**当子类的成员变量或方法与父类同名时，可以使用 super 关键字来访问。**如果子类重写了父类的某一个方法，即子类和父类有相同的方法定义，但是有不同的方法体，此时，我们可以通过 super 来调用父类里面的这个方法。

```java
class Person {
    int age = 12;
}
class Student extends Person {
    int age = 18;
    void display() {
        System.out.println("学生年龄：" + super.age);//访问父类变量，区别子类和父类同名的属性
    }
}
class Test {
    public static void main(String[] args) {
        Student stu = new Student();
        stu.display();
    }
}
```

```java
class Person {
    void message() {
        System.out.println("This is person class");
    }
}
class Student extends Person {
    void message() {
        System.out.println("This is student class");
    }
    void display() {
        message();
        super.message();//访问父类方法，区别子类和父类同名的方法
    }
}
class Test {
    public static void main(String args[]) {
        Student s = new Student();
        s.display();
    }
}
```

# 十二、多态

## （一）对象类型转换

将一个类型强制转换成另一个类型的过程称为**类型转换**。存在继承关系的对象才有对象类型转换，否则会抛出强制类型转换异常。

### 1.向上转型

​	**父类引用指向子类对象称之为向上转型**。形如`Father f = new Son();`，向上转型是不用强制转换的，但是得到的父类引用可以使用父类中的成员，但是不能调用子类特有的成员，损失了一些子类的功能，**这些损失的功能，只是无法访问，依然还存在，可以通过强制向下转型恢复回来**，形如`Son s = (Son)f;`。向上转型是是安全的，一定不会出错的。

### 2.向下转型

​	**子类引用指向父类对象称之为向下转型。**形如`Son s = (Son)f;`。注意：单纯的使用向下转型，Son s = new Father(); 会出错，必须配合向上转型一起使用

```java
class Person {
    void message() {
        System.out.println("This is person class");
    }
}
class Student extends Person {
    //重写父类的方法
    void message() {
        System.out.println("This is student class");
    }
    //子类特有的方法
    void display() {
        System.out.println("This is student display");
    }

}
class Test {
    public static void main(String args[]) {
        Person p = new Student();//向上转型
        p.display();//报错！！dispaly()方法是子类特有的方法，无法通过向上转型的父类引用调用
        p.message();//正常！！message()方法是在子类中重写了的父类的方法，通过向上转型的父类引用调用的是子类中重写的方法。
        System.out.println(p instanceof Student);//true
        System.out.println(p instanceof Person); //true  
        Student s = (Student)p;
        s.display();//正常
        s.message();//正常
    }
}
```







