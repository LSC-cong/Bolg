# 一、类与对象

## （一）封装

### 1.特点

- **封装是将代码及其处理的数据绑定在一起的一种编程机制，该机制保证了程序和数据都不受外部干扰且不被误用。**==封装的目的在于保护信息==**。
- 封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。

- Java 语言的基本封装单位是类。由于类的用途是封装复杂性，所以类的内部有隐藏实现复杂性的机制。Java 提供了私有和公有的访问模式，类的公有接口代表外部的用户应该知道或可以知道的每件东西，私有的方法数据只能通过该类的成员代码来访问，这就可以确保不会发生不希望的事情。

### 2.优点

- **保护类中的信息，它可以阻止在外部定义的代码随意访问内部代码和数据。**
- **隐藏细节信息**，一些不需要程序员修改和使用的信息，比如取款机中的键盘，用户只需要知道按哪个键实现什么操作就可以，至于它内部是如何运行的，用户不需要知道。
- **有助于建立各个系统之间的松耦合关系，提高系统的独立性。**当一个系统的实现方式发生变化时，只要它的接口不变，就不会影响其他系统的使用。例如 U 盘，不管里面的存储方式怎么改变，只要 U 盘上的 USB 接口不变，就不会影响用户的正常操作。
- **提高软件的复用率，降低成本。**每个系统都是一个相对独立的整体，可以在不同的环境中得到使用。例如，一个 U 盘可以在多台电脑上使用。

## （二）继承

### 特点

- **程序中的继承性是指子类拥有父类的全部特征和行为，这是类之间的一种关系**。
- **不同类型的对象，内部存在一定的共性，继承是使用已存在的类的定义作为基础建立新类。通过继承提高代码的重用性。程序的可维护性，提高开发效率。**
- **C++支持多继承，多继承就是一个子类可有多个父类**。多继承会引起很多冲突问题，因此现在很多面向对象的语言都不支持多继承。**Java 语言是单继承的，即只能有一个父类，但 Java 可以实现多个接口**。接口类似于类，但接口的成员没有执行体，可以防止多继承所引起的冲突问题。

## （三）多态

### 1.特点

- 面向对象的多态性，即“一个接口，多个方法”。多态性体现在父类中定义的属性和方法被子类继承后，可以具有不同的属性或表现方式。多态性允许一个接口被多个同类使用，弥补了单继承的不足。
- 父类的某个方法被子类重写时，可以产生自己的功能行为，同一个操作作用于不同对象，可以有不同的解释，产生不同的执行结果简单来说就是**同一个事件发生在不同的对象上会产生不同的结果。**
- 封装和继承就是为多态做准备的，多态的三个前提条件：**继承父类、重写父类的方法、父类的引用指向子类对象（即向上转型）。**

### 2.实现方式

- 接口实现

- 继承父类**方法重写**

- 同一类中进行**方法重载**

## （四）类的定义

```java
[public][abstract|final]class<class_name>[extends<class_name>][implements<interface_name>] {
    // 定义属性部分
    <property_type> <property1>;
    <property_type> <property2>;
    <property_type> <property3>;
    …
    // 定义方法部分
    function1();
    function2();
    function3();
    …
}
```

## （五）对象的创建

> - 使用 new 关键字或 Class 对象的 newInstance() 方法创建对象时，都会调用类的构造方法。
> - 使用 Class 类的 newInstance() 方法创建对象时，会调用类的默认构造方法，即无参构造方法。
> - 使用 Object 类的 clone() 方法创建对象时，不会调用类的构造方法，它会创建一个复制的对象，这个对象和原来的对象具有不同的内存地址，但它们的属性值相同。

### 1.使用new关键字

```java
类名 对象名 = new 类名()；
```

- 创建匿名对象
  - 每次 new 都相当于开辟了一个新的对象，并开辟了一个新的物理内存空间。如果一个对象只需要使用唯一的一次，就可以使用匿名对象，实际开发中匿名对象常常作为实际参数传递。
  - 匿名对象就是没有给出名字的对象，是一种简写的形式，一般只使用一次。而且匿名对象只在堆内存中开辟空间，不存在栈内存的引用。

````java
new Person("张三", 30).toString(); // 匿名对象
````

- 不同的方式定义字符串时堆和栈的变化
  - `String a;` 只是在栈中创建了一个 String 类的对象引用变量 a。
  - `String a = "C语言中文网";`在栈中创建一个 String 类的对象引用变量 a，然后查找栈中有没有存放“C语言中文网”，如果有则直接指向“C语言中文网"，如果没有，则将”C语言中文网“存放进栈，再指向。
  - `String a = new String("C语言中文网");`不仅在栈中创建一个 String 类的对象引用变量 a，同时也在堆中开辟一块空间存放新建的 String 对象“C语言中文网”，变量 a 指向堆中的新建的 String 对象”C语言中文网“。

> 堆是用来存放由 new 创建的对象和数组，即动态申请的内存都存放在堆区。栈是用来存放在方法中定义的一些基本类型的变量和对象的引用变量。



### 2.调用newlnstance()方法

在 Java 中，可以使用 java.lang.Class 或者 java.lang.reflect.Constuctor 类的 newlnstance() 实例方法来创建对象

```java
Class Class类对象名称 = Class.forName(要实例化的类全称);
要实例化的类名 对象名 = (要实例化的类名)Class类对象名称.newInstance();
```

### 3.调用对象的clone()方法

该方法不常用，使用该方法创建对象时，要**实例化的类必须继承 java.lang.Cloneable 接口**。 

```java
类名对象名 = (类名)已创建好的类对象名.clone();
```

### 4.调用readObject() 方法

调用 java.io.ObjectlnputStream 对象的 readObject() 方法

```java
public class Student implements Cloneable {
    // 实现 Cloneable 接口
    private String Name;    // 学生名字
    private int age;    // 学生年龄
    public Student(String name,int age) {
        // 构造方法
        this.Name = name;
        this.age = age;
    }
    public Student() {
        this.Name = "name";
        this.age = 0;
    }
    public String toString() {
        return"学生名字："+Name+"，年龄："+age;
    }
    public static void main(String[] args)throws Exception {
        // 使用new关键字创建对象
        Student student1 = new Student("小刘",22);
        System.out.println(student1);

        // 调用 java.lang.Class 的 newInstance() 方法创建对象
        Class c1 = Class.forName("Student");
        Student student2 = (Student)c1.newInstance();
        System.out.println(student2);

        // 调用对象的 clone() 方法创建对象
        Student student3 = (Student)student2.clone();
        System.out.println(student3);
    }
}
```

### 5.隐式的的创建对象

- String strName = "strValue"，其中的“strValue”就是一个 String 对象，由 Java 虚拟机隐含地创建。

- 字符串的“+”运算符运算的结果为一个新的 String 对象

```java
String str1 = "Hello";
String str2 = "Java";
String str3 = str1+str2;    // str3引用一个新的String对象
```

- 当 Java 虚拟机加载一个类时，会隐含地创建描述这个类的 Class 实例。
  - 类的加载是指把类的 .class 文件中的二进制数据读入内存中，把它存放在运行时数据区的方法区内，然后在堆区创建一个 java.lang.Class 对象，用来封装类在方法区内的数据结构

> 注意：无论釆用哪种方式创建对象，Java 虚拟机在创建一个对象时都包含以下步骤：
>
> - 给对象分配内存。
> - 将对象的实例变量自动初始化为其变量类型的默认值。
> - 初始化对象，给实例变量赋予正确的初始值。

# 二、成员变量与局部变量

```java
[public|protected|private][static][final]<type><variable_name>
/*
各参数的含义如下。
public、protected、private：用于表示成员变量的访问权限。
static：表示该成员变量为类变量，也称为静态变量。
final：表示将该成员变量声明为常量，其值无法更改。
type：表示变量的类型。
variable_name：表示变量名称。
*/
```

> 初始化的默认值如下：
>
> - 整数型（byte、short、int 和 long）的基本类型变量的默认值为 0。
> - 单精度浮点型（float）的基本类型变量的默认值为 0.0f。
> - 双精度浮点型（double）的基本类型变量的默认值为 0.0d。
> - 字符型（char）的基本类型变量的默认值为 “\u0000”。
> - 布尔型的基本类型变量的默认值为 false。
> - 数组引用类型的变量的默认值为 null。如果创建了数组变量的实例，但没有显式地为每个元素赋值，则数组中的元素初始化值采用数组数据类型对应的默认值。

### 1.成员变量

又叫成员属性，定义了类的属性，作用域为整个类

### 2.局部变量

- **在方法体内可以定义本方法所使用的变量，这种变量是局部变量**。它的生存期与作用域是在本方法内，也就是说，**局部变量只能在本方法内有效或可见，离开本方法则这些变量将被自动释放。**

- **在方法体内定义变量时，变量前不能加修饰符**。局部变量在使用前必须明确赋值，否则编译时会出错。

# 三、成员方法

​	**声明成员方法可以定义类的行为**，行为表示一个对象能够做的事情或者能够从一个对象取得的信息。**类的各种功能操作都是用方法来实现的，属性只不过提供了相应的数据**。==**一个完整的方法通常包括  方法返回值类型、方法名称、方法参数、方法主体**==

```java
public class Test {
    [public|private|protected][static]<void|return_type><method_name>([paramList]) {
        // 方法体
    }
}
```

### 形参与实参

- **形参**是定义方法时参数列表中出现的参数，实参是调用方法时为方法传递的参数

- **形参变量只有在被调用时才分配内存单元，在调用结束时，即刻释放所分配的内存单元**。因此，形参只有在方法内部有效，方法调用结束返回主调方法后则不能再使用该形参变量。
- **实参可以是常量、变量、表达式、方法等，无论实参是何种类型的量，在进行方法调用时，它们都必须具有确定的值，以便把这些值传送给形参**。因此应预先用赋值、输入等办法使实参获得确定值。

# 四、this关键字

this 关键字是Java常用的关键字。主要有三个应用：

### 1.this调用当前对象中的成员变量；

- 正常情况下引用属性都是以  **对象.属性** 的形式。但是**当成员变量和局部变量重名时，为了区分，在方法中使用this，表示该方法所在类中的成员变量。this表示的是当前类的对象**

```java
class hello{
    public static void main(String [] args){
        //Person p1 = new Person(张三",20,"男"); //调用有参构造函数，对成员变量进行初始化
        Person p1 = new Person(); //调用无参构造函数，使用setXxx()方法对成员变量进行初始化赋值，也可以
        p1.setAge(20);
        p1.setName("张三");
        p1.setGender("男");
        System.out.println(""+p1.getName()+" 今年"+p1.getAge()+"岁 性别为："+p1.getGender());
    }
}
class Person{
    private String name;
    private int age;
    private String gender;
    Person(){}
    Person(String name,int age,String gender){
        this.name = name;
        this.age = age;
        this.gender = gender;
    }
    public void setName(String name){
        this.name = name;//this表示当前对象的实例，即p1，this.name表示p1实例中的name，是成员变量，name表示所在方法中的方法参数name，是局部变量
    }
    public String getName(){
        return name;
    }
    public void setAge(int age){
        this.age = age;
    }
    public int getAge(){
        return age;
    }
    public void setGender(String gender){
        this.gender = gender;
    }
    public String getGender(){
        return gender;
    }
}
```

### 2.this调用当前对象中的其他成员方法；

- this 关键字最大的作用就是让类中一个方法，访问该类中的另一个方法，而不用重新创建一个新的实例。

- this 可以代表任何对象，当 this 出现在某个方法体中时，它所代表的对象是不确定的，但它的类型是确定的，**它所代表的只能是当前类的实例**。只有当这个方法被调用时，它所代表的对象才被确定下来，谁在调用这个方法，this 就代表谁。
- 对于 static 修饰的方法而言，可以使用类来直接调用该方法，如果在 static 修饰的方法中使用 this 关键字，则这个关键字就无法指向合适的对象。**所以，static 修饰的方法中不能使用 this 引用。并且 Java 语法规定，静态成员不能直接访问非静态成员。**

```java
public class DogTest{
    public static void main(String[] args) {
        // 创建Dog对象
        Dog dog = new Dog();
        // 调用Dog对象的run()方法
        dog.run();
    }
}
class Dog {
    // 定义一个jump()方法
    public void jump() {System.out.println("正在执行jump方法");}
    // 定义一个run()方法，run()方法需要借助jump()方法
    public void run() {
        //方式一，不使用this，重新创建一个新的类，再调用jump()方法
        //Dog d = new Dog();
        //d.jump();
        //方式二，使用this，this表示当前Dog类的实例（如dog）
        //因为当程序调用 run( ) 方法时，一定会提供一个 Dog 对象，这样就可以直接使用这个已经存在的 Dog 对象，而无须重新创建新的 Dog 对象了。因此需要在 run() 方法中获得调用该方法的对象，通过 this 关键字就可以满足这个要求。
        this.jump();
        System.out.println("正在执行 run 方法");
    }
}
```



### 3.this()调用当前对象中的其他构造方法

> 一个类中有多个构造函数，有时候需要在一个构造函数中调用其他的构造函数，避免代码重复，使用this关键字。
>
> 在java编程思想中有这样一段话：通常写this的时候，都是指“这个对象”或者“当前对象”，而且它本身表示对当前对象的引用。在构造器中，如果为this添加了参数列表，那么就有不同的含义。这将产生对符合此参数列表的某个构造器的明确调用；这样调用其他构造函数就有了直接的途径。

- **this()只能放在构造方法中，不能放在普通方法中，要放在构造方法的首行，而且一个构造方法内只能调用一个构造方法**；
  - 规定放在构造方法首行的原因是，不会使得  this(xxx，xxx)  调用的其他有参构造影响当前有参构造的赋值。

```java
Person(String name){
    this.name = name;
}
Person(String name,int age,String gender){
    //this("lsc");调用的是Person(String name)构造参数，对name进行初始化，
    this("lsc");//放在这里不影响后面，第二条语句this.name = name;对name变量的初始化，因为this("lsc")的效果会被覆盖。
    this.name = name;
    this.age = age;
    this.gender = gender;
    //this("lsc");//放在这里会覆盖掉当前构造函数的初始化结果，不好。
}
```

- **()中可以有参数，就是调用指定的有参构造**

# 五、注释

## （一）类注释

类注释一般必须放在所有的“import”语句之后，类定义之前，主要声明该类可以做什么，以及创建者、创建日期、版本和包名等一些信息。一般来说，创建人，创建时间，类描述是必要的

```java
/**
 * @projectName（项目名称）: project_name
 * @package（包）: package_name.file_name
 * @className（类名称）: type_name
 * @description（类描述）: 一句话描述该类的功能
 * @author（创建人）: user 
 * @createDate（创建时间）: datetime  
 * @updateUser（修改人）: user 
 * @updateDate（修改时间）: datetime
 * @updateRemark（修改备注）: 说明本次修改内容
 * @version（版本）: v1.0
 */
```

## （二）方法注释

方法注释必须紧靠在方法定义的前面，**主要声明方法参数、返回值、异常等信息**。

```java
/**
* @description 方法描述：描述方法的功能
* @param 变量描述：对当前方法的参数部分添加一个说明，可以占据多行。一个方法的所有 @param 标记必须放在一起。
* @return 返回类型描述：对当前方法添加返回值部分，可以跨越多行。
* @throws 异常类描述：表示这个方法有可能抛出异常。有关异常的详细内容将在第 10 章中讨论。
*/
```

## （三）字段注释

字段注释在定义字段的前面，用来描述字段的含义。





